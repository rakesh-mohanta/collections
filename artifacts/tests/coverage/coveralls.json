{"service_name":"travis-ci","service_job_id":"10390601","git":{"branch":"(detached from 3f42c13)","head":{"id":"3f42c132a6f91425d2b140fcfda5e7cb041a79f4","author_name":"James Harris","author_email":"james.harris@icecave.com.au","committer_name":"James Harris","committer_email":"james.harris@icecave.com.au","message":"Fixed a few minor documentation issues."},"remotes":[{"name":"origin","url":"git:\/\/github.com\/IcecaveStudios\/collections.git"}]},"run_at":"2013-08-20 01:25:16 +0000","source_files":[{"name":"Icecave\/Collections\/AssociativeInterface.php","source":"<?php\nnamespace Icecave\\Collections;\n\n\/**\n * An associative collection is a variable-sized collection that supports efficient retrieval of values based on keys.\n *\n * Each element in an associative collection is a 2-tuple of key and value.\n *\/\ninterface AssociativeInterface extends IterableInterface\n{\n    \/**\n     * Check if the collection contains an element with the given key.\n     *\n     * @param mixed $key The key to check.\n     *\n     * @return boolean True if the collection contains the given key; otherwise, false.\n     *\/\n    public function hasKey($key);\n\n    \/**\n     * Fetch the value associated with the given key.\n     *\n     * @param mixed $key The key to fetch.\n     *\n     * @return mixed                         The associated value.\n     * @throws Exception\\UnknownKeyException if no such key exists.\n     *\/\n    public function get($key);\n\n    \/**\n     * Fetch the value associated with the given key if it exists.\n     *\n     * @param mixed $key    The key to fetch.\n     * @param mixed &$value Assigned the value associated with $key if it exists.\n     *\n     * @return boolean True if $key exists and $value was populated; otherwise, false.\n     *\/\n    public function tryGet($key, &$value);\n\n    \/**\n     * Fetch the value associated with the given key, or a default value if it does not exist.\n     *\n     * @param mixed $key     The key to fetch.\n     * @param mixed $default The default value to return if $key does not exist.\n     *\n     * @return mixed The value associated with $key, or the $default if nos such key exists.\n     *\/\n    public function getWithDefault($key, $default = null);\n\n    \/**\n     * Return the value associated with the first key that exists.\n     *\n     * Takes a variable number of keys and searches for each one in order,\n     * returns the value associated with the first key that exists.\n     *\n     * @param mixed $key            The key to search for.\n     * @param mixed $additional,... Additional keys to search for.\n     *\n     * @return mixed                         The value associated with the first key that exists.\n     * @throws Exception\\UnknownKeyException if none of the keys exist.\n     *\/\n    public function cascade($key);\n\n    \/**\n     * Return the value associated with the first key that exists, or a default value if none of the provided keys exist.\n     *\n     * @param mixed $default        The default value to return if no such keys exist.\n     * @param mixed $key            The key to search for.\n     * @param mixed $additional,... Additional keys to search for.\n     *\n     * @return mixed The value associated with the first key that exists, or $default if none of the keys exist.\n     *\/\n    public function cascadeWithDefault($default, $key);\n\n    \/**\n     * Return the value associated with the first existing key in the given sequence.\n     *\n     * Behaves as per {@see AssociativeInterface::cascade()} except that the keys are provided as\n     * a traversable (eg, array) instead of via a variable argument list.\n     *\n     * @param mixed<mixed> $keys The list of keys.\n     *\n     * @return mixed                         The value associated with the first key that exists.\n     * @throws Exception\\UnknownKeyException if none of the keys exist.\n     *\/\n    public function cascadeIterable($keys);\n\n    \/**\n     * Return the value associated with the first existing key in the given sequence, or a default value if none of the provided keys exist.\n     *\n     * Behaves as per {@see AssociativeInterface::cascadeDefault()} except that the keys are provided as\n     * a traversable (eg, array) instead of via a variable argument list.\n     *\n     * @param mixed        $default The default value to return if no such keys exist.\n     * @param mixed<mixed> $keys    The list of keys.\n     *\n     * @return mixed The value associated with the first key that exists, or $default if none of the keys exist.\n     *\/\n    public function cascadeIterableWithDefault($default, $keys);\n\n    \/**\n     * Fetch a native array containing the keys in the collection.\n     *\n     * There is no guarantee that the order of keys will match the order of values produced by {@see AssociativeInterface::values()}.\n     *\n     * @return array A native array containing the keys in the collection.\n     *\/\n    public function keys();\n\n    \/**\n     * Fetch a native array containing the values in the collection.\n     *\n     * There is no guarantee that the order of values will match the order of keys produced by {@see AssociativeInterface::keys()}.\n     *\n     * @return array A native array containing the values in the collection.\n     *\/\n    public function values();\n\n    \/**\n     * Produce a new collection containing the elements of this collection and one or more other collections.\n     *\n     * Any existing keys are overwritten from left to right.\n     * It is not guaranteed that the concrete type of the merged collection will match this collection.\n     *\n     * @param AssociativeInterface $collection     The collection to combine.\n     * @param AssociativeInterface $additional,... Additional collections to combine.\n     *\n     * @return AssociativeInterface The merged collection.\n     *\/\n    public function merge(AssociativeInterface $collection);\n\n    \/**\n     * Create a new collection containing the elements associated with the provided keys.\n     *\n     * It is not guaranteed that the concrete type of the projected collection will match this collection.\n     *\n     * @param mixed $key            The key to include in the new collection.\n     * @param mixed $additional,... \u00c5dditional keys to include in the new collection.\n     *\n     * @return AssociativeInterface The projection of the collection.\n     *\/\n    public function project($key);\n\n    \/**\n     * Create a new collection containing the elements associated with the provided keys.\n     *\n     * It is not guaranteed that the concrete type of the projected collection will match this collection.\n     *\n     * @param mixed<mixed> $keys The keys to include in the new collection.\n     *\n     * @return AssociativeInterface The projection of the collection.\n     *\/\n    public function projectIterable($keys);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Collections\/Collection.php","source":"<?php\nnamespace Icecave\\Collections;\n\nuse ArrayAccess;\nuse Countable;\nuse Icecave\\Collections\\Iterator\\Traits;\nuse Icecave\\Collections\\Iterator\\TraitsProviderInterface;\nuse Icecave\\Collections\\TypeCheck\\TypeCheck;\nuse SplDoublyLinkedList;\nuse SplHeap;\nuse SplPriorityQueue;\nuse SplFixedArray;\nuse SplObjectStorage;\nuse Traversable;\n\n\/**\n * Utility functions for working with arbitrary collection types.\n *\/\nabstract class Collection\n{\n    \/**\n     * Check if a collection is empty.\n     *\n     * @param array|Traversable|CollectionInterface $collection\n     *\n     * @return boolean True if $collection is contains zero elements; otherwise false.\n     *\/\n    public static function isEmpty($collection)\n    {\n        TypeCheck::get(__CLASS__)->isEmpty(func_get_args());\n\n        if ($collection instanceof CollectionInterface) {\n            return $collection->isEmpty();\n        }\n\n        return 0 === static::size($collection);\n    }\n\n    \/**\n     * Get the number of elements in a collection.\n     *\n     * @param array|Traversable|Countable|CollectionInterface $collection\n     *\n     * @return integer The number of elements in $collection\n     *\/\n    public static function size($collection)\n    {\n        TypeCheck::get(__CLASS__)->size(func_get_args());\n\n        if ($collection instanceof CollectionInterface) {\n            return $collection->size();\n        } elseif ($collection instanceof Countable) {\n            return count($collection);\n        } elseif (is_array($collection)) {\n            return count($collection);\n        }\n\n        $count = 0;\n        foreach ($collection as $value) {\n            ++$count;\n        }\n\n        return $count;\n    }\n\n    \/**\n     * Fetch the value associated with the given key.\n     *\n     * @param array|Traversable|AssociativeInterface $collection\n     * @param mixed                                  $key        The key to fetch.\n     *\n     * @return mixed                         The associated value.\n     * @throws Exception\\UnknownKeyException if no such key exists.\n     *\/\n    public static function get($collection, $key)\n    {\n        TypeCheck::get(__CLASS__)->get(func_get_args());\n\n        $value = null;\n        if (static::tryGet($collection, $key, $value)) {\n            return $value;\n        }\n\n        throw new Exception\\UnknownKeyException($key);\n    }\n\n    \/**\n     * Fetch the value associated with the given key if it exists.\n     *\n     * @param array|Traversable|AssociativeInterface $collection\n     * @param mixed                                  $key        The key to fetch.\n     * @param mixed                                  &$value     Assigned the value associated with $key if it exists.\n     *\n     * @return boolean True if $key exists and $value was populated; otherwise, false.\n     *\/\n    public static function tryGet($collection, $key, &$value)\n    {\n        TypeCheck::get(__CLASS__)->tryGet(func_get_args());\n\n        if ($collection instanceof AssociativeInterface) {\n            return $collection->tryGet($key, $value);\n        } elseif (is_array($collection)) {\n            if (array_key_exists($key, $collection)) {\n                $value = $collection[$key];\n\n                return true;\n            }\n\n            return false;\n        }\n\n        return static::any(\n            $collection,\n            function ($k, $v) use ($key, &$value) {\n                if ($k === $key) {\n                    $value = $v;\n\n                    return true;\n                }\n\n                return false;\n            }\n        );\n    }\n\n    \/**\n     * Fetch the value associated with the given key, or a default value if it does not exist.\n     *\n     * @param array|Traversable|IterableInterface $collection\n     * @param mixed                               $key        The key to fetch.\n     * @param mixed                               $default    The default value to return if $key does not exist.\n     *\n     * @return mixed The value associated with $key, or the $default if nos such key exists.\n     *\/\n    public static function getWithDefault($collection, $key, $default = null)\n    {\n        TypeCheck::get(__CLASS__)->getWithDefault(func_get_args());\n\n        $value = null;\n        if (static::tryGet($collection, $key, $value)) {\n            return $value;\n        }\n\n        return $default;\n    }\n\n    \/**\n     * Check if the collection contains an element with the given key.\n     *\n     * @param array|Traversable|IterableInterface $collection\n     * @param mixed                               $key        The key to check.\n     *\n     * @return boolean True if the collection contains the given key; otherwise, false.\n     *\/\n    public static function hasKey($collection, $key)\n    {\n        TypeCheck::get(__CLASS__)->hasKey(func_get_args());\n\n        if ($collection instanceof AssociativeInterface) {\n            return $collection->hasKey($key);\n        } elseif ($collection instanceof SequenceInterface) {\n            return is_int($key) && $key >= 0 && $key < $collection->size();\n        } elseif (is_array($collection)) {\n            return array_key_exists($key, $collection);\n        }\n\n        return static::any(\n            $collection,\n            function ($k, $v) use ($key) {\n                return $k === $key;\n            }\n        );\n    }\n\n    \/**\n     * Check if the collection contains an element with the given value.\n     *\n     * @param array|Traversable|IterableInterface $collection\n     * @param mixed                               $value      The value to check.\n     *\n     * @return boolean True if the collection contains $value; otherwise, false.\n     *\/\n    public static function contains($collection, $value)\n    {\n        TypeCheck::get(__CLASS__)->contains(func_get_args());\n\n        if ($collection instanceof IterableInterface) {\n            return $collection->contains($value);\n        } elseif (is_array($collection)) {\n            return false !== array_search($value, $collection, true);\n        }\n\n        return static::any(\n            $collection,\n            function ($k, $v) use ($value) {\n                return $v === $value;\n            }\n        );\n    }\n\n    \/**\n     * Get the keys of a collection.\n     *\n     * @param array|Traversable|AssociativeInterface|SequenceInterface $collection\n     *\n     * @return array An array containing the keys of $collection.\n     *\/\n    public static function keys($collection)\n    {\n        TypeCheck::get(__CLASS__)->keys(func_get_args());\n\n        if ($collection instanceof AssociativeInterface) {\n            return $collection->keys();\n        } elseif ($collection instanceof SequenceInterface) {\n            return range(0, $collection->size() - 1);\n        } elseif (is_array($collection)) {\n            return array_keys($collection);\n        }\n\n        $keys = array();\n        foreach ($collection as $value) {\n            $keys[] = $collection->key(); \/\/ https:\/\/bugs.php.net\/bug.php?id=45684\n        }\n\n        return $keys;\n    }\n\n    \/**\n     * Get the values of a collection.\n     *\n     * @param array|Traversable|AssociativeInterface|SequenceInterface $collection\n     *\n     * @return array An array containing the values of $collection.\n     *\/\n    public static function values($collection)\n    {\n        TypeCheck::get(__CLASS__)->values(func_get_args());\n\n        if ($collection instanceof AssociativeInterface) {\n            return $collection->values();\n        } elseif ($collection instanceof SequenceInterface) {\n            return $collection->elements();\n        } elseif (is_array($collection)) {\n            return array_values($collection);\n        }\n\n        $values = array();\n        foreach ($collection as $value) {\n            $values[] = $value;\n        }\n\n        return $values;\n    }\n\n    \/**\n     * Get the elements of a collection.\n     *\n     * Elements are 2-tuples of key and value (even for sequential collection types).\n     *\n     * @param array|Traversable|CollectionInterface $collection\n     *\n     * @return array An array containing the elements of $collection.\n     *\/\n    public static function elements($collection)\n    {\n        TypeCheck::get(__CLASS__)->elements(func_get_args());\n\n        if ($collection instanceof AssociativeInterface) {\n            return $collection->elements();\n        }\n\n        $elements = array();\n\n        static::each(\n            $collection,\n            function ($key, $value) use (&$elements) {\n                $elements[] = array($key, $value);\n            }\n        );\n\n        return $elements;\n    }\n\n    \/**\n     * Produce a new collection by applying a transformation to each element.\n     *\n     * The transform must be a callable with the following signature:\n     *  function (mixed $key, mixed $value) { return array($new_key, $new_value); }\n     *\n     * @param array|Traversable|IterableInterface $collection\n     * @param callable                            $transform  The transform to apply to each element.\n     * @param array|ArrayAccess                   &$result\n     *\n     * @return array|ArrayAccess Returns $result.\n     *\/\n    public static function map($collection, $transform, &$result = array())\n    {\n        TypeCheck::get(__CLASS__)->map(func_get_args());\n\n        static::each(\n            $collection,\n            function ($key, $value) use ($transform, &$result) {\n                list($key, $value) = call_user_func($transform, $key, $value);\n                $result[$key] = $value;\n            }\n        );\n\n        return $result;\n    }\n\n    \/**\n     * Fetch a new collection with a subset of the elements from this collection.\n     *\n     * The predicate must be a callable with the following signature:\n     *  function (mixed $key, mixed $value) { return $true_to_retain_element; }\n     *\n     * @param array|Traversable|IterableInterface $collection\n     * @param callable|null                       $predicate  A predicate function used to determine which elements to include, or null to include all non-null elements.\n     * @param array|ArrayAccess                   &$result\n     *\n     * @return array|ArrayAccess Returns $result.\n     *\/\n    public static function filter($collection, $predicate, &$result = array())\n    {\n        TypeCheck::get(__CLASS__)->filter(func_get_args());\n\n        static::each(\n            $collection,\n            function ($key, $value) use ($predicate, &$result) {\n                if (call_user_func($predicate, $key, $value)) {\n                    $result[$key] = $value;\n                }\n            }\n        );\n\n        return $result;\n    }\n\n    \/**\n     * Invokes the given callback on every element in the collection.\n     *\n     * This method behaves the same as {@see Collection::map()} except that the return value of the callback is not retained.\n     *\n     * @param array|Traversable|IterableInterface $collection\n     * @param callable                            $callback   The callback to invoke with each element.\n     *\/\n    public static function each($collection, $callback)\n    {\n        TypeCheck::get(__CLASS__)->each(func_get_args());\n\n        static::all(\n            $collection,\n            function ($key, $value) use ($callback) {\n                call_user_func($callback, $key, $value);\n\n                return true;\n            }\n        );\n    }\n\n    \/**\n     * Returns true if the given predicate returns true for all elements.\n     *\n     * The loop is short-circuited, exiting after the first element for which the predicate returns false.\n     *\n     * @param array|Traversable|IterableInterface $collection\n     * @param callable                            $predicate\n     *\n     * @return boolean True if $predicate($key, $value) returns true for all elements; otherwise, false.\n     *\/\n    public static function all($collection, $predicate)\n    {\n        TypeCheck::get(__CLASS__)->all(func_get_args());\n\n        if ($collection instanceof IterableInterface) {\n            \/\/ Wrap the callback such that a sequential index is produced for the first argument ...\n            if ($collection instanceof SequenceInterface) {\n                $index = 0;\n                $original = $predicate;\n                $predicate = function ($value) use (&$index, $original) {\n                    return call_user_func($original, $index++, $value);\n                };\n            }\n\n            return $collection->all($predicate);\n        } elseif (is_array($collection)) {\n            foreach ($collection as $key => $value) {\n                if (!call_user_func($predicate, $key, $value)) {\n                    return false;\n                }\n            }\n        } else {\n            foreach ($collection as $value) {\n                $key = $collection->key(); \/\/ https:\/\/bugs.php.net\/bug.php?id=45684\n                if (!call_user_func($predicate, $key, $value)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    \/**\n     * Returns true if the given predicate returns true for any element.\n     *\n     * The loop is short-circuited, exiting after the first element for which the predicate returns false.\n     *\n     * @param array|Traversable|IterableInterface $collection\n     * @param callable                            $predicate\n     *\n     * @return boolean True if $predicate($key, $value) returns true for any element; otherwise, false.\n     *\/\n   public static function any($collection, $predicate)\n   {\n        TypeCheck::get(__CLASS__)->any(func_get_args());\n\n        return !static::all(\n            $collection,\n            function ($key, $value) use ($predicate) {\n                return !call_user_func($predicate, $key, $value);\n            }\n        );\n    }\n\n    \/**\n     * Check if a collection contains sequential integer keys.\n     *\n     * @param array|Traversable|CollectionInterface $collection\n     *\n     * @return boolean True if the collection contains sequential integer keys; otherwise, false.\n     *\/\n    public static function isSequential($collection)\n    {\n        TypeCheck::get(__CLASS__)->isSequential(func_get_args());\n\n        if ($collection instanceof CollectionInterface) {\n            return $collection instanceof SequenceInterface;\n        }\n\n        $expectedKey = 0;\n\n        return static::all(\n            $collection,\n            function ($key, $value) use (&$expectedKey) {\n                return $key === $expectedKey++;\n            }\n        );\n    }\n\n    \/**\n     * Fetch the traits for an iterator.\n     *\n     * @param array|Traversable|Countable|TraitsProviderInterface $iterator\n     *\n     * @return Traits\n     *\/\n    public static function iteratorTraits($iterator)\n    {\n        TypeCheck::get(__CLASS__)->iteratorTraits(func_get_args());\n\n        if ($iterator instanceof TraitsProviderInterface) {\n            return $iterator->iteratorTraits();\n        } elseif (is_array($iterator)) {\n            return new Traits(true, true);\n        } elseif ($iterator instanceof SplDoublyLinkedList) {\n            return new Traits(true, true);\n        } elseif ($iterator instanceof SplHeap) {\n            return new Traits(true, true);\n        } elseif ($iterator instanceof SplPriorityQueue) {\n            return new Traits(true, true);\n        } elseif ($iterator instanceof SplFixedArray) {\n            return new Traits(true, true);\n        } elseif ($iterator instanceof SplObjectStorage) {\n            return new Traits(true, true);\n        } else {\n            return new Traits($iterator instanceof Countable, false);\n        }\n    }\n\n    \/**\n     * Return the index of the first element in a sorted collection that is not less than the given element.\n     *\n     * @param array|ArrayAccess $collection The sorted collection to search.\n     * @param mixed             $element    The element to search for.\n     * @param callable          $comparator The comparator used to compare elements.\n     * @param integer           $startIndex The index at which to start the search.\n     * @param integer|null      $endIndex   The index at which to stop the search, or null to use the entire collection.\n     *\/\n    public static function lowerBound($collection, $element, $comparator, $startIndex = 0, $endIndex = null)\n    {\n        TypeCheck::get(__CLASS__)->lowerBound(func_get_args());\n\n        if (null === $endIndex) {\n            $endIndex = static::size($collection);\n        }\n\n        $count = $endIndex - $startIndex;\n\n        while ($count > 0) {\n            $step = intval($count \/ 2);\n            $pivotIndex = $startIndex + $step;\n\n            if (call_user_func($comparator, $collection[$pivotIndex], $element) < 0) {\n                $startIndex = $pivotIndex + 1;\n                $count -= $step + 1;\n            } else {\n                $count = $step;\n            }\n        }\n\n        return $startIndex;\n    }\n\n    \/**\n     * Return the index of the first element in a sorted collection that is greater than the given element.\n     *\n     * @param array|ArrayAccess $collection The sorted collection to search.\n     * @param mixed             $element    The element to search for.\n     * @param callable          $comparator The comparator used to compare elements.\n     * @param integer           $startIndex The index at which to start the search.\n     * @param integer|null      $endIndex   The index at which to stop the search, or null to use the entire collection.\n     *\/\n    public static function upperBound($collection, $element, $comparator, $startIndex = 0, $endIndex = null)\n    {\n        TypeCheck::get(__CLASS__)->upperBound(func_get_args());\n\n        if (null === $endIndex) {\n            $endIndex = static::size($collection);\n        }\n\n        $count = $endIndex - $startIndex;\n\n        while ($count > 0) {\n            $step = intval($count \/ 2);\n            $pivotIndex = $startIndex + $step;\n\n            if (call_user_func($comparator, $collection[$pivotIndex], $element) <= 0) {\n                $startIndex = $pivotIndex + 1;\n                $count -= $step + 1;\n            } else {\n                $count = $step;\n            }\n        }\n\n        return $startIndex;\n    }\n\n    \/**\n     * Perform a binary search on a sorted sequence.\n     *\n     * @param array|ArrayAccess $collection   The collection to search.\n     * @param mixed             $element      The element to search for.\n     * @param callable          $comparator   The comparator used to compare elements.\n     * @param integer           $startIndex   The index at which to start the search.\n     * @param integer|null      $endIndex     The index at which to stop the search, or null to use the entire collection.\n     * @param integer|null      &$insertIndex Assigned the index at which $element must be inserted to maintain sortedness.\n     *\n     * @return integer|null The index at which an element equal to $element is present in $collection.\n     *\/\n    public static function binarySearch($collection, $element, $comparator, $startIndex = 0, $endIndex = null, &$insertIndex = null)\n    {\n        TypeCheck::get(__CLASS__)->binarySearch(func_get_args());\n\n        if (null === $endIndex) {\n            $endIndex = static::size($collection);\n        }\n\n        $insertIndex = static::lowerBound($collection, $element, $comparator, $startIndex, $endIndex);\n\n        if ($insertIndex === $endIndex) {\n            return null;\n        } elseif (0 !== call_user_func($comparator, $collection[$insertIndex], $element)) {\n            return null;\n        }\n\n        return $insertIndex;\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,5,null,5,2,null,null,3,null,null,null,null,null,null,null,null,null,null,null,25,null,25,2,23,2,21,19,null,null,2,2,2,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,10,null,10,10,5,null,null,5,null,null,null,null,null,null,null,null,null,null,null,null,null,30,null,30,6,24,6,3,null,3,null,null,3,null,null,18,18,null,18,9,null,9,null,null,18,null,18,null,null,null,null,null,null,null,null,null,null,null,null,null,10,null,10,10,5,null,null,5,null,null,null,null,null,null,null,null,null,null,null,null,5,null,5,1,4,1,3,1,null,null,2,2,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,5,null,5,2,3,1,null,null,2,2,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,5,null,5,1,4,1,3,1,null,null,2,2,2,2,null,2,null,null,null,null,null,null,null,null,null,null,null,5,null,5,1,4,1,3,1,null,null,2,2,2,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,5,null,5,1,null,null,4,null,4,4,null,4,4,4,null,4,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,15,null,15,15,null,15,15,15,15,null,15,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,15,null,15,15,null,15,15,15,15,15,null,15,null,null,null,null,null,null,null,null,null,null,null,null,39,null,39,39,null,39,null,39,null,39,39,null,null,null,null,null,null,null,null,null,null,null,null,null,74,null,74,null,25,16,16,null,16,16,16,null,25,49,11,11,2,null,11,10,38,38,38,14,null,38,null,null,40,null,null,null,null,null,null,null,null,null,null,null,null,null,null,27,null,27,27,null,27,null,27,null,null,null,null,null,null,null,null,null,null,null,5,null,5,2,null,null,3,null,3,3,null,3,null,3,null,null,null,null,null,null,null,null,null,null,null,12,null,12,1,11,1,10,3,7,2,5,1,4,1,3,1,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,23,null,23,6,6,null,23,null,23,23,23,null,23,15,15,15,18,null,23,null,23,null,null,null,null,null,null,null,null,null,null,null,null,null,12,null,12,6,6,null,12,null,12,12,12,null,12,10,10,10,7,null,12,null,12,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,11,null,11,5,5,null,11,null,11,3,8,3,null,null,5,null,null]},{"name":"Icecave\/Collections\/CollectionInterface.php","source":"<?php\nnamespace Icecave\\Collections;\n\n\/**\n * A collection is an object that stores other objects (called elements).\n *\/\ninterface CollectionInterface\n{\n    \/**\n     * Fetch the number of elements in the collection.\n     *\n     * @see CollectionInterface::isEmpty()\n     *\n     * @return integer The number of elements in the collection.\n     *\/\n    public function size();\n\n    \/**\n     * Check if the collection is empty.\n     *\n     * @return boolean True if the collection is empty; otherwise, false.\n     *\/\n    public function isEmpty();\n\n    \/**\n     * Fetch a string representation of the collection.\n     *\n     * The string may not describe all elements of the collection, but should at least\n     * provide information on the type and state of the collection.\n     *\n     * @return string A string representation of the collection.\n     *\/\n    public function __toString();\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Collections\/Exception\/CollectionExceptionInterface.php","source":"<?php\nnamespace Icecave\\Collections\\Exception;\n\n\/**\n * A common interface for all collection exceptions.\n *\/\ninterface CollectionExceptionInterface\n{\n}","coverage":[null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Collections\/Exception\/DuplicateKeyException.php","source":"<?php\nnamespace Icecave\\Collections\\Exception;\n\nuse Exception;\nuse Icecave\\Collections\\TypeCheck\\TypeCheck;\nuse Icecave\\Repr\\Repr;\nuse RuntimeException;\n\n\/**\n * The key of an associative collection already exists in the set of existing keys.\n *\/\nclass DuplicateKeyException extends RuntimeException implements CollectionExceptionInterface\n{\n    \/**\n     * @param mixed          $key      The unknown key.\n     * @param Exception|null $previous The previous exception, if any.\n     *\/\n    public function __construct($key, Exception $previous = null)\n    {\n        TypeCheck::get(__CLASS__, func_get_args());\n\n        parent::__construct('Key ' . Repr::repr($key) . ' already exists.', 0, $previous);\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,null]},{"name":"Icecave\/Collections\/Exception\/EmptyCollectionException.php","source":"<?php\nnamespace Icecave\\Collections\\Exception;\n\nuse Exception;\nuse Icecave\\Collections\\TypeCheck\\TypeCheck;\nuse UnderflowException;\n\n\/**\n * An operation requiring an element was performed on an empty collection.\n *\/\nclass EmptyCollectionException extends UnderflowException implements CollectionExceptionInterface\n{\n    \/**\n     * @param Exception|null $previous The previous exception, if any.\n     *\/\n    public function __construct(Exception $previous = null)\n    {\n        TypeCheck::get(__CLASS__, func_get_args());\n\n        parent::__construct('Collection is empty.', 0, $previous);\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,null]},{"name":"Icecave\/Collections\/Exception\/IndexException.php","source":"<?php\nnamespace Icecave\\Collections\\Exception;\n\nuse Exception;\nuse Icecave\\Collections\\TypeCheck\\TypeCheck;\nuse OutOfBoundsException;\n\n\/**\n * The index (subscript) of a random-access sequence was out of range.\n *\/\nclass IndexException extends OutOfBoundsException implements CollectionExceptionInterface\n{\n    \/**\n     * @param integer        $index    The out-of-range index.\n     * @param Exception|null $previous The previous exception, if any.\n     *\/\n    public function __construct($index, Exception $previous = null)\n    {\n        TypeCheck::get(__CLASS__, func_get_args());\n\n        parent::__construct('Index ' . $index . ' is out of range.', 0, $previous);\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,null]},{"name":"Icecave\/Collections\/Exception\/UnknownKeyException.php","source":"<?php\nnamespace Icecave\\Collections\\Exception;\n\nuse Exception;\nuse Icecave\\Collections\\TypeCheck\\TypeCheck;\nuse Icecave\\Repr\\Repr;\nuse OutOfBoundsException;\n\n\/**\n * The key of an associative collection was not found in the set of existing keys.\n *\/\nclass UnknownKeyException extends OutOfBoundsException implements CollectionExceptionInterface\n{\n    \/**\n     * @param mixed          $key      The unknown key.\n     * @param Exception|null $previous The previous exception, if any.\n     *\/\n    public function __construct($key, Exception $previous = null)\n    {\n        TypeCheck::get(__CLASS__, func_get_args());\n\n        parent::__construct('Key ' . Repr::repr($key) . ' does not exist.', 0, $previous);\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,null]},{"name":"Icecave\/Collections\/HashSet.php","source":"<?php\nnamespace Icecave\\Collections;\n\nuse ArrayIterator;\nuse Countable;\nuse Icecave\\Collections\\Iterator\\SequentialKeyIterator;\nuse Icecave\\Collections\\Iterator\\Traits;\nuse Icecave\\Collections\\TypeCheck\\TypeCheck;\nuse Icecave\\Repr\\Repr;\nuse InvalidArgumentException;\nuse IteratorAggregate;\nuse Serializable;\n\n\/**\n * An iterable collection with unique elements.\n *\/\nclass HashSet implements MutableIterableInterface, Countable, IteratorAggregate, Serializable\n{\n    \/**\n     * @param mixed<mixed>|null $collection   An iterable type containing the elements to include in this set, or null to create an empty set.\n     * @param callable|null     $hashFunction The function to use for generating hashes of elements, or null to use the default.\n     *\/\n    public function __construct($collection = null, $hashFunction = null)\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n\n        if (null === $hashFunction) {\n            $hashFunction = new Utility\\AssociativeKeyGenerator;\n        }\n\n        $this->hashFunction = $hashFunction;\n        $this->elements = array();\n\n        if (null !== $collection) {\n            foreach ($collection as $element) {\n                $this->add($element);\n            }\n        }\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of CollectionInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Fetch the number of elements in the collection.\n     *\n     * @see HashSet::isEmpty()\n     *\n     * @return integer The number of elements in the collection.\n     *\/\n    public function size()\n    {\n        $this->typeCheck->size(func_get_args());\n\n        return count($this->elements);\n    }\n\n    \/**\n     * Check if the collection is empty.\n     *\n     * @return boolean True if the collection is empty; otherwise, false.\n     *\/\n    public function isEmpty()\n    {\n        $this->typeCheck->isEmpty(func_get_args());\n\n        return empty($this->elements);\n    }\n\n    \/**\n     * Fetch a string representation of the collection.\n     *\n     * The string may not describe all elements of the collection, but should at least\n     * provide information on the type and state of the collection.\n     *\n     * @return string A string representation of the collection.\n     *\/\n    public function __toString()\n    {\n        if ($this->isEmpty()) {\n            return '<HashSet 0>';\n        } elseif ($this->size() > 3) {\n            $format = '<HashSet %d [%s, ...]>';\n            $elements = array_slice($this->elements, 0, 3);\n        } else {\n            $format = '<HashSet %d [%s]>';\n            $elements = $this->elements;\n        }\n\n        return sprintf(\n            $format,\n            $this->size(),\n            implode(\n                ', ',\n                array_map(\n                    'Icecave\\Repr\\Repr::repr',\n                    $elements\n                )\n            )\n        );\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of MutableCollectionInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Remove all elements from the collection.\n     *\/\n    public function clear()\n    {\n        $this->typeCheck->clear(func_get_args());\n\n        $this->elements = array();\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of IteratorTraitsProvider \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Return traits describing the collection's iteration capabilities.\n     *\n     * @return Traits\n     *\/\n    public function iteratorTraits()\n    {\n        $this->typeCheck->iteratorTraits(func_get_args());\n\n        return new Traits(true, true);\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of IterableInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Fetch a native array containing the elements in the collection.\n     *\n     * @return array An array containing the elements in the collection.\n     *\/\n    public function elements()\n    {\n        $this->typeCheck->elements(func_get_args());\n\n        return array_values($this->elements);\n    }\n\n    \/**\n     * Check if the collection contains an element with the given value.\n     *\n     * @param mixed $element The value to check.\n     *\n     * @return boolean True if the collection contains $element; otherwise, false.\n     *\/\n    public function contains($element)\n    {\n        $this->typeCheck->contains(func_get_args());\n\n        return array_key_exists(\n            $this->generateHash($element),\n            $this->elements\n        );\n    }\n\n    \/**\n     * Fetch a new collection with a subset of the elements from this collection.\n     *\n     * The predicate must be a callable with the following signature:\n     *  function (mixed $element) { return $true_to_retain_element; }\n     *\n     * @param callable|null $predicate A predicate function used to determine which elements to include, or null to include all non-null elements.\n     *\n     * @return HashSet The filtered collection.\n     *\/\n    public function filter($predicate = null)\n    {\n        $this->typeCheck->filter(func_get_args());\n\n        if (null === $predicate) {\n            $predicate = function ($element) {\n                return null !== $element;\n            };\n        }\n\n        $result = $this->createSet();\n\n        foreach ($this->elements as $hash => $element) {\n            if (call_user_func($predicate, $element)) {\n                $result->elements[$hash] = $element;\n            }\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Produce a new collection by applying a transformation to each element.\n     *\n     * The new elements produced by the transform need not be of the same type.\n     * It is not guaranteed that the concrete type of the resulting collection will match this collection.\n     *\n     * The transform must be a callable with the following signature:\n     *  function (mixed $element) { return $new_element; }\n     *\n     * @param callable $transform The transform to apply to each element.\n     *\n     * @return IterableInterface A new collection produced by applying $transform to each element in this collection.\n     *\/\n    public function map($transform)\n    {\n        $this->typeCheck->map(func_get_args());\n\n        $result = $this->createSet();\n        $result->addMany(\n            array_map($transform, $this->elements)\n        );\n\n        return $result;\n    }\n\n    \/**\n     * Partitions this collection into two collections according to a predicate.\n     *\n     * It is not guaranteed that the concrete type of the partitioned collections will match this collection.\n     *\n     * @param callable $predicate A predicate function used to determine which partitioned collection to place the elements in.\n     *\n     * @return tuple<IterableInterface,IterableInterface> A 2-tuple containing the partitioned collections. The first collection contains the element for which the predicate returned true.\n     *\/\n    public function partition($predicate)\n    {\n        $this->typeCheck->partition(func_get_args());\n\n        $left  = $this->createSet();\n        $right = $this->createSet();\n\n        foreach ($this->elements as $hash => $element) {\n            if (call_user_func($predicate, $element)) {\n                $left->elements[$hash] = $element;\n            } else {\n                $right->elements[$hash] = $element;\n            }\n        }\n\n        return array($left, $right);\n    }\n\n    \/**\n     * Invokes the given callback on every element in the collection.\n     *\n     * This method behaves the same as {@see IterableInterface::map()} except that the return value of the callback is not retained.\n     *\n     * @param callable $callback The callback to invoke with each element.\n     *\/\n    public function each($callback)\n    {\n        $this->typeCheck->each(func_get_args());\n\n        foreach ($this->elements as $element) {\n            call_user_func($callback, $element);\n        }\n    }\n\n    \/**\n     * Returns true if the given predicate returns true for all elements.\n     *\n     * The loop is short-circuited, exiting after the first element for which the predicate returns false.\n     *\n     * @param callable $predicate\n     *\n     * @return boolean True if $predicate($element) returns true for all elements; otherwise, false.\n     *\/\n    public function all($predicate)\n    {\n        $this->typeCheck->all(func_get_args());\n\n        foreach ($this->elements as $element) {\n            if (!call_user_func($predicate, $element)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \/**\n     * Returns true if the given predicate returns true for any element.\n     *\n     * The loop is short-circuited, exiting after the first element for which the predicate returns false.\n     *\n     * @param callable $predicate\n     *\n     * @return boolean True if $predicate($element) returns true for any element; otherwise, false.\n     *\/\n    public function any($predicate)\n    {\n        $this->typeCheck->any(func_get_args());\n\n        foreach ($this->elements as $element) {\n            if (call_user_func($predicate, $element)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of MutableIterableInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Filter this collection in-place.\n     *\n     * The predicate must be a callable with the following signature:\n     *  function (mixed $element) { return $true_to_retain_element; }\n     *\n     * @param callable|null $predicate A predicate function used to determine which elements to retain, or null to retain all elements with non-null values.\n     *\/\n    public function filterInPlace($predicate = null)\n    {\n        $this->typeCheck->filterInPlace(func_get_args());\n\n        if (null === $predicate) {\n            $predicate = function ($element) {\n                return null !== $element;\n            };\n        }\n\n        foreach ($this->elements as $hash => $element) {\n            if (!call_user_func($predicate, $element)) {\n                unset($this->elements[$hash]);\n            }\n        }\n    }\n\n    \/**\n     * Replace each element in the collection with the result of a transformation on that element.\n     *\n     * The new elements produced by the transform must be the same type.\n     *\n     * The transform must be a callable with the following signature:\n     *  function (mixed $element) { return $element; }\n     *\n     * @param callable $transform The transform to apply to each element.\n     *\/\n    public function mapInPlace($transform)\n    {\n        $this->typeCheck->mapInPlace(func_get_args());\n\n        $keep = array();\n\n        foreach ($this->elements as $hash => $element) {\n            $newElement = call_user_func($transform, $element);\n            $newHash = $this->generateHash($newElement);\n            $keep[$newHash] = true;\n\n            if ($hash !== $newHash) {\n                $this->elements[$newHash] = $newElement;\n                if (!array_key_exists($hash, $keep)) {\n                    unset($this->elements[$hash]);\n                }\n            }\n        }\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of Countable \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    public function count()\n    {\n        $this->typeCheck->count(func_get_args());\n\n        return $this->size();\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of IteratorAggregate \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    public function getIterator()\n    {\n        $this->typeCheck->getIterator(func_get_args());\n\n        return new SequentialKeyIterator(\n            new ArrayIterator($this->elements)\n        );\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of Serializable \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Serialize the collection.\n     *\n     * @return string The serialized data.\n     *\/\n    public function serialize()\n    {\n        $this->typeCheck->serialize(func_get_args());\n\n        return serialize(\n            array(\n                $this->elements(),\n                $this->hashFunction\n            )\n        );\n    }\n\n    \/**\n     * Unserialize collection data.\n     *\n     * @param string $packet The serialized data.\n     *\/\n    public function unserialize($packet)\n    {\n        TypeCheck::get(__CLASS__)->unserialize(func_get_args());\n\n        list($elements, $hashFunction) = unserialize($packet);\n        $this->__construct($elements, $hashFunction);\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Model specific methods \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Return the first of the given elements that is contained in the set.\n     *\n     * @param mixed $element        The element to search for.\n     * @param mixed $additional,... Additional elements to search for.\n     *\n     * @return mixed                         The first of the given elements that is contained in the set.\n     * @throws Exception\\UnknownKeyException if none of the elements exist.\n     *\/\n    public function cascade($element)\n    {\n        $this->typeCheck->cascade(func_get_args());\n\n        return $this->cascadeIterable(func_get_args());\n    }\n\n    \/**\n     * Return the first of the given elements that is contained in the set, or a default if none are found.\n     *\n     * @param mixed $default        The default value to return if no such elements exist.\n     * @param mixed $element        The element to search for.\n     * @param mixed $additional,... Additional elements to search for.\n     *\n     * @return mixed The first of the given elements that is contained in the set, or $default if none are found.\n     *\/\n    public function cascadeWithDefault($default, $element)\n    {\n        $this->typeCheck->cascadeWithDefault(func_get_args());\n\n        $elements = func_get_args();\n        $default = array_shift($elements);\n\n        return $this->cascadeIterableWithDefault($default, $elements);\n    }\n\n    \/**\n     * Return the first of the given elements that is contained in the set.\n     *\n     * Behaves as per {@see HashSet::cascade()} except that the elements are provided as\n     * a traversable (eg, array) instead of via a variable argument list.\n     *\n     * @param mixed<mixed> $elements The list of elements.\n     *\n     * @return mixed                         The first of the given elements that is contained in the set.\n     * @throws Exception\\UnknownKeyException if none of the elements exist.\n     *\/\n    public function cascadeIterable($elements)\n    {\n        $this->typeCheck->cascadeIterable(func_get_args());\n\n        foreach ($elements as $element) {\n            if ($this->contains($element)) {\n                return $element;\n            }\n        }\n\n        throw new Exception\\UnknownKeyException($element);\n    }\n\n    \/**\n     * Return the first of the given elements that is contained in the set, or a default if none are found.\n     *\n     * Behaves as per {@see HashSet::cascadeDefault()} except that the elements are provided as\n     * a traversable (eg, array) instead of via a variable argument list.\n     *\n     * @param mixed        $default  The default value to return if no such elements exist.\n     * @param mixed<mixed> $elements The list of elements.\n     *\n     * @return mixed The first of the given elements that is contained in the set, or $default if none are found.\n     *\/\n    public function cascadeIterableWithDefault($default, $elements)\n    {\n        $this->typeCheck->cascadeIterableWithDefault(func_get_args());\n\n        foreach ($elements as $element) {\n            if ($this->contains($element)) {\n                return $element;\n            }\n        }\n\n        return $default;\n    }\n\n    \/**\n     * Add an element to the set.\n     *\n     * @param mixed $element The element to add.\n     *\n     * @return boolean True if the element was added to the set, or false if the set already contained the element.\n     *\/\n    public function add($element)\n    {\n        $this->typeCheck->add(func_get_args());\n\n        $size = $this->size();\n        $hash = $this->generateHash($element);\n\n        $this->elements[$hash] = $element;\n\n        return $size < $this->size();\n    }\n\n    \/**\n     * Add multiple elements to the set.\n     *\n     * @see HashSet::unionInPlace() may be faster when adding all elements from a another set.\n     *\n     * @param mixed<mixed> $elements The elements to add.\n     *\/\n    public function addMany($elements)\n    {\n        $this->typeCheck->addMany(func_get_args());\n\n        foreach ($elements as $element) {\n            $hash = $this->generateHash($element);\n            $this->elements[$hash] = $element;\n        }\n    }\n\n    \/**\n     * Remove an element from the set, if it exists.\n     *\n     * @param mixed $element The element to remove.\n     *\n     * @return boolean True if the element was removed from the set, or false if the set dot not contain the element.\n     *\/\n    public function remove($element)\n    {\n        $this->typeCheck->remove(func_get_args());\n\n        $size = $this->size();\n        $hash = $this->generateHash($element);\n\n        unset($this->elements[$hash]);\n\n        return $size > $this->size();\n    }\n\n    \/**\n     * Remove multiple elements from the set.\n     *\n     * @see HashSet::diffInPlace() may be faster when removing all elements from a another set.\n     *\n     * @param mixed<mixed> $elements The elements to remote.\n     *\/\n    public function removeMany($elements)\n    {\n        $this->typeCheck->removeMany(func_get_args());\n\n        foreach ($elements as $element) {\n            $hash = $this->generateHash($element);\n            unset($this->elements[$hash]);\n        }\n    }\n\n    \/**\n     * Check if this set is equal to another.\n     *\n     * @param HashSet $set The set to compare against.\n     *\n     * @return boolean True if this set contains the same elements as $set; otherwise false.\n     *\/\n    public function isEqualSet(HashSet $set)\n    {\n        $this->typeCheck->isEqualSet(func_get_args());\n\n        $this->assertCompatible($set);\n\n        if ($this->size() !== $set->size()) {\n            return false;\n        }\n\n        foreach ($set->elements as $hash => $element) {\n            if (!array_key_exists($hash, $this->elements)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \/**\n     * Check if this set is a superset of another.\n     *\n     * @param HashSet $set The set to compare against.\n     *\n     * @return boolean True if this set contains all of the elements in $set; otherwise, false.\n     *\/\n    public function isSuperSet(HashSet $set)\n    {\n        $this->typeCheck->isSuperSet(func_get_args());\n\n        $this->assertCompatible($set);\n\n        if ($this->size() < $set->size()) {\n            return false;\n        }\n\n        foreach ($set->elements as $hash => $element) {\n            if (!array_key_exists($hash, $this->elements)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \/**\n     * Check if this set is a subset of another.\n     *\n     * @param HashSet $set The set to compare against.\n     *\n     * @return boolean True if this set contains only elements present in $set; otherwise, false.\n     *\/\n    public function isSubSet(HashSet $set)\n    {\n        $this->typeCheck->isSubSet(func_get_args());\n\n        $this->assertCompatible($set);\n\n        return $set->isSuperSet($this);\n    }\n\n    \/**\n     * Check if this set is a proper superset of another.\n     *\n     * @param HashSet $set The set to compare against.\n     *\n     * @return boolean True if this set contains all of elements in $set, but is not equal to $set; otherwise, false.\n     *\/\n    public function isProperSuperSet(HashSet $set)\n    {\n        $this->typeCheck->isProperSuperSet(func_get_args());\n\n        $this->assertCompatible($set);\n\n        if ($this->size() <= $set->size()) {\n            return false;\n        }\n\n        foreach ($set->elements as $hash => $element) {\n            if (!array_key_exists($hash, $this->elements)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \/**\n     * Check if this set is a proper subset of another.\n     *\n     * @param HashSet $set The set to compare against.\n     *\n     * @return boolean True if this set contains only elements present in $set, but is not equal to $set; otherwise, false.\n     *\/\n    public function isProperSubSet(HashSet $set)\n    {\n        $this->typeCheck->isProperSubSet(func_get_args());\n\n        $this->assertCompatible($set);\n\n        return $set->isProperSuperSet($this);\n    }\n\n    \/**\n     * Check if this set is intersecting another.\n     *\n     * @param HashSet $set The set to compare against.\n     *\n     * @return boolean True if this set contains one or more elements present in $set; otherwise false.\n     *\/\n    public function isIntersecting(HashSet $set)\n    {\n        $this->typeCheck->isIntersecting(func_get_args());\n\n        $this->assertCompatible($set);\n\n        foreach ($set->elements as $hash => $element) {\n            if (array_key_exists($hash, $this->elements)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    \/**\n     * Compute the union of this set and another.\n     *\n     * @param HashSet $set The second set.\n     *\n     * @return HashSet A set containing all elements of $this and $elements.\n     *\/\n    public function union(HashSet $set)\n    {\n        $this->typeCheck->union(func_get_args());\n\n        $this->assertCompatible($set);\n\n        $result = $this->createSet();\n        $result->elements = $this->elements + $set->elements;\n\n        return $result;\n    }\n\n    \/**\n     * Compute the union of this set and another, in place.\n     *\n     * @param HashSet $set The second set.\n     *\/\n    public function unionInPlace(HashSet $set)\n    {\n        $this->typeCheck->unionInPlace(func_get_args());\n\n        $this->assertCompatible($set);\n\n        $this->elements += $set->elements;\n    }\n\n    \/**\n     * Compute the intersection of this set and another.\n     *\n     * @param HashSet $set The second set.\n     *\n     * @return HashSet A set containing only the elements present in $this and $elements.\n     *\/\n    public function intersect(HashSet $set)\n    {\n        $this->typeCheck->intersect(func_get_args());\n\n        $this->assertCompatible($set);\n\n        $result = $this->createSet();\n        $result->elements = array_intersect_key($this->elements, $set->elements);\n\n        return $result;\n    }\n\n    \/**\n     * Compute the intersection of this set and another, in place.\n     *\n     * @param HashSet $set The second set.\n     *\/\n    public function intersectInPlace(HashSet $set)\n    {\n        $this->typeCheck->intersectInPlace(func_get_args());\n\n        $this->assertCompatible($set);\n\n        foreach ($this->elements as $hash => $element) {\n            if (!array_key_exists($hash, $set->elements)) {\n                unset($this->elements[$hash]);\n            }\n        }\n    }\n\n    \/**\n     * Compute the difference (or complement) of this set and another.\n     *\n     * @param HashSet $set The second set.\n     *\n     * @return HashSet A set containing only the elements present in $this, but not $elements.\n     *\/\n    public function diff(HashSet $set)\n    {\n        $this->typeCheck->diff(func_get_args());\n\n        $this->assertCompatible($set);\n\n        $result = $this->createSet();\n        $result->elements = array_diff_key($this->elements, $set->elements);\n\n        return $result;\n    }\n\n    \/**\n     * Compute the difference (or complement) of this set and another, in place.\n     *\n     * @param HashSet $set The second set.\n     *\/\n    public function diffInPlace(HashSet $set)\n    {\n        $this->typeCheck->diffInPlace(func_get_args());\n\n        $this->assertCompatible($set);\n\n        foreach ($set->elements as $hash => $element) {\n            unset($this->elements[$hash]);\n        }\n    }\n\n    \/**\n     * Compute the symmetric difference (or complement) of this set and another.\n     *\n     * The symmetric difference is the set of elements which are in either of the sets and not in their intersection.\n     *\n     * @param HashSet $set The second set.\n     *\n     * @return HashSet A set containing only the elements present in $this, or $elements, but not both.\n     *\/\n    public function symmetricDiff(HashSet $set)\n    {\n        $this->typeCheck->symmetricDiff(func_get_args());\n\n        $this->assertCompatible($set);\n\n        $result = $this->union($set);\n        $result->diffInPlace(\n            $this->intersect($set)\n        );\n\n        return $result;\n    }\n\n    \/**\n     * Compute the symmetric difference (or complement) of this set and another, in place.\n     *\n     * The symmetric difference is the set of elements which are in either of the sets and not in their intersection.\n     *\n     * @param HashSet $set The second set.\n     *\/\n    public function symmetricDiffInPlace(HashSet $set)\n    {\n        $this->typeCheck->symmetricDiffInPlace(func_get_args());\n\n        $this->assertCompatible($set);\n\n        $intersection = $this->intersect($set);\n        $this->unionInPlace($set);\n        $this->diffInPlace($intersection);\n    }\n\n    \/**\n     * @param mixed $key\n     *\n     * @return integer|string\n     *\/\n    private function generateHash($key)\n    {\n        return call_user_func($this->hashFunction, $key);\n    }\n\n    \/**\n     * @return HashSet\n     *\/\n    private function createSet()\n    {\n        return new self(null, $this->hashFunction);\n    }\n\n    \/**\n     * @param HashSet $set\n     *\/\n    private function assertCompatible(HashSet $set)\n    {\n        if ($set->hashFunction != $this->hashFunction) {\n            throw new InvalidArgumentException('The given set does not use the same hashing algorithm.');\n        }\n    }\n\n    private $typeCheck;\n    private $hashFunction;\n    private $elements;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,189,null,189,184,184,null,189,189,null,189,185,156,185,185,189,null,null,null,null,null,null,null,null,null,null,null,null,null,null,178,null,178,null,null,null,null,null,null,null,null,null,3,null,3,null,null,null,null,null,null,null,null,null,null,null,null,1,1,1,1,1,1,1,1,null,null,1,1,1,1,1,1,1,null,1,1,1,null,null,null,null,null,null,null,null,null,null,null,4,null,4,4,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,3,null,null,null,null,null,null,null,null,null,null,null,8,null,8,8,8,8,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,1,1,1,1,null,2,null,2,2,2,2,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,null,1,1,1,1,1,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,1,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,1,1,1,1,null,2,2,2,2,2,2,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,1,1,1,1,null,1,1,1,1,1,1,1,1,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,1,null,1,1,1,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,2,2,2,2,null,null,null,null,null,null,null,null,null,2,null,2,2,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,3,3,2,null,3,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,2,2,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,164,null,164,164,null,164,null,164,null,null,null,null,null,null,null,null,null,null,null,204,null,204,176,176,204,204,null,null,null,null,null,null,null,null,null,null,2,null,2,2,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,1,1,null,null,null,null,null,null,null,null,null,null,14,null,14,null,13,7,null,null,6,5,4,null,4,null,2,null,null,null,null,null,null,null,null,null,null,null,27,null,27,null,26,7,null,null,19,15,11,null,11,null,8,null,null,null,null,null,null,null,null,null,null,null,14,null,14,null,13,null,null,null,null,null,null,null,null,null,null,null,27,null,27,null,26,19,null,null,7,5,3,null,5,null,4,null,null,null,null,null,null,null,null,null,null,null,14,null,14,null,13,null,null,null,null,null,null,null,null,null,null,null,14,null,14,null,13,12,6,null,10,null,7,null,null,null,null,null,null,null,null,null,null,null,27,null,27,null,26,26,null,26,null,null,null,null,null,null,null,null,null,27,null,27,null,26,26,null,null,null,null,null,null,null,null,null,null,40,null,40,null,39,39,null,39,null,null,null,null,null,null,null,null,null,14,null,14,null,13,11,9,9,13,13,null,null,null,null,null,null,null,null,null,null,14,null,14,null,13,13,null,13,null,null,null,null,null,null,null,null,null,40,null,40,null,39,23,39,39,null,null,null,null,null,null,null,null,null,null,null,null,14,null,14,null,13,13,13,13,null,13,null,null,null,null,null,null,null,null,null,null,null,14,null,14,null,13,13,13,13,null,null,null,null,null,null,null,null,200,null,null,null,null,null,null,null,69,null,null,null,null,null,null,null,196,14,null,182,null,null,null,null,null]},{"name":"Icecave\/Collections\/IterableInterface.php","source":"<?php\nnamespace Icecave\\Collections;\n\nuse Icecave\\Collections\\Iterator\\TraitsProviderInterface;\n\n\/**\n * Iterable collections allow (at the very least) sequential access to the elements without modifying the collection.\n *\n * In general there is no guarantee that the elements of a collection are stored in any definite order;\n * the order might, in fact, be different upon each iteration through the collection. However, some\n * specific collection types may provide such guarantees.\n *\/\ninterface IterableInterface extends CollectionInterface, TraitsProviderInterface\n{\n    \/**\n     * Fetch a native array containing the elements in the collection.\n     *\n     * @return array An array containing the elements in the collection.\n     *\/\n    public function elements();\n\n    \/**\n     * Check if the collection contains an element.\n     *\n     * @param mixed $element The element to check.\n     *\n     * @return boolean True if the collection contains $element; otherwise, false.\n     *\/\n    public function contains($element);\n\n    \/**\n     * Fetch a new collection with a subset of the elements from this collection.\n     *\n     * It is not guaranteed that the concrete type of the filtered collection will match this collection.\n     *\n     * @param callable|null $predicate A predicate function used to determine which elements to include, or null to include all non-null elements.\n     *\n     * @return IterableInterface The filtered collection.\n     *\/\n    public function filter($predicate = null);\n\n    \/**\n     * Produce a new collection by applying a transformation to each element.\n     *\n     * The new elements produced by the transform need not be of the same type.\n     * It is not guaranteed that the concrete type of the resulting collection will match this collection.\n     *\n     * @param callable $transform The transform to apply to each element.\n     *\n     * @return IterableInterface A new collection produced by applying $transform to each element in this collection.\n     *\/\n    public function map($transform);\n\n    \/**\n     * Partitions this collection into two collections according to a predicate.\n     *\n     * It is not guaranteed that the concrete type of the partitioned collections will match this collection.\n     *\n     * @param callable $predicate A predicate function used to determine which partitioned collection to place the elements in.\n     *\n     * @return tuple<IterableInterface,IterableInterface> A 2-tuple containing the partitioned collections. The first collection contains the element for which the predicate returned true.\n     *\/\n    public function partition($predicate);\n\n    \/**\n     * Invokes the given callback on every element in the collection.\n     *\n     * This method behaves the same as {@see IterableInterface::map()} except that the return value of the callback is not retained.\n     *\n     * @param callable $callback The callback to invoke with each element.\n     *\/\n    public function each($callback);\n\n    \/**\n     * Returns true if the given predicate returns true for all elements.\n     *\n     * The loop is short-circuited, exiting after the first element for which the predicate returns false.\n     *\n     * @param callable $predicate\n     *\n     * @return boolean True if $predicate($element) returns true for all elements; otherwise, false.\n     *\/\n    public function all($predicate);\n\n    \/**\n     * Returns true if the given predicate returns true for any element.\n     *\n     * The loop is short-circuited, exiting after the first element for which the predicate returns false.\n     *\n     * @param callable $predicate\n     *\n     * @return boolean True if $predicate($element) returns true for any element; otherwise, false.\n     *\/\n    public function any($predicate);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Collections\/Iterator\/AssociativeIterator.php","source":"<?php\nnamespace Icecave\\Collections\\Iterator;\n\nuse Icecave\\Collections\\AssociativeInterface;\nuse Icecave\\Collections\\TypeCheck\\TypeCheck;\nuse Iterator;\n\n\/**\n * A generic iterator for any collection that implement AssociativeInterface.\n *\n * Note that the concrete implementations provided in this package may provide their own\n * iterator for performance reasons.\n *\/\nclass AssociativeIterator implements Iterator\n{\n    \/**\n     * @param AssociativeInterface $collection The collection to be iterated.\n     *\/\n    public function __construct(AssociativeInterface $collection)\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n\n        $this->index = 0;\n        $this->collection = $collection;\n    }\n\n    \/**\n     * Fetch the collection to be iterated.\n     *\n     * @return AssociativeInterface The collection to be iterated.\n     *\/\n    public function collection()\n    {\n        $this->typeCheck->collection(func_get_args());\n\n        return $this->collection;\n    }\n\n    \/**\n     * Fetch the current value.\n     *\n     * @return mixed The current value.\n     *\/\n    public function current()\n    {\n        $this->typeCheck->current(func_get_args());\n\n        return $this->collection->get($this->key());\n    }\n\n    \/**\n     * Fetch the current key.\n     *\n     * @return mixed The current key.\n     *\/\n    public function key()\n    {\n        $this->typeCheck->key(func_get_args());\n\n        $keys = $this->collection->keys();\n\n        return $keys[$this->index];\n    }\n\n    \/**\n     * Advance to the next element.\n     *\/\n    public function next()\n    {\n        $this->typeCheck->next(func_get_args());\n\n        ++$this->index;\n    }\n\n    \/**\n     * Rewind to the first element.\n     *\/\n    public function rewind()\n    {\n        $this->typeCheck->rewind(func_get_args());\n\n        $this->index = 0;\n    }\n\n    \/**\n     * Check if the current element is valid.\n     *\n     * @return boolean True if the iterator points to a valid element; otherwise, false.\n     *\/\n    public function valid()\n    {\n        $this->typeCheck->valid(func_get_args());\n\n        return $this->index < $this->collection->size()\n            && $this->collection->hasKey($this->key());\n    }\n\n    private $typeCheck;\n    private $index;\n    private $collection;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,2,2,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,1,null,1,null,1,null,null,null,null,null,null,null,1,null,1,1,null,null,null,null,null,null,1,null,1,1,null,null,null,null,null,null,null,null,1,null,1,1,null,null,null,null,null,null]},{"name":"Icecave\/Collections\/Iterator\/RandomAccessIterator.php","source":"<?php\nnamespace Icecave\\Collections\\Iterator;\n\nuse Icecave\\Collections\\RandomAccessInterface;\nuse Icecave\\Collections\\TypeCheck\\TypeCheck;\nuse Iterator;\n\n\/**\n * A generic iterator for any collection that implement RandomAccessInterface.\n *\n * Note that the concrete implementations provided in this package may provide their own\n * iterator for performance reasons.\n *\/\nclass RandomAccessIterator implements Iterator\n{\n    \/**\n     * @param RandomAccessInterface $collection The collection to be iterated.\n     *\/\n    public function __construct(RandomAccessInterface $collection)\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n\n        $this->index = 0;\n        $this->collection = $collection;\n    }\n\n    \/**\n     * Fetch the collection to be iterated.\n     *\n     * @return RandomAccessInterface The collection to be iterated.\n     *\/\n    public function collection()\n    {\n        $this->typeCheck->collection(func_get_args());\n\n        return $this->collection;\n    }\n\n    \/**\n     * Fetch the current value.\n     *\n     * @return mixed The current value.\n     *\/\n    public function current()\n    {\n        $this->typeCheck->current(func_get_args());\n\n        return $this->collection->get($this->index);\n    }\n\n    \/**\n     * Fetch the current key.\n     *\n     * @return mixed The current key.\n     *\/\n    public function key()\n    {\n        $this->typeCheck->key(func_get_args());\n\n        return $this->index;\n    }\n\n    \/**\n     * Advance to the next element.\n     *\/\n    public function next()\n    {\n        $this->typeCheck->next(func_get_args());\n\n        ++$this->index;\n    }\n\n    \/**\n     * Rewind to the first element.\n     *\/\n    public function rewind()\n    {\n        $this->typeCheck->rewind(func_get_args());\n\n        $this->index = 0;\n    }\n\n    \/**\n     * Check if the current element is valid.\n     *\n     * @return boolean True if the iterator points to a valid element; otherwise, false.\n     *\/\n    public function valid()\n    {\n        $this->typeCheck->valid(func_get_args());\n\n        return $this->index < $this->collection->size();\n    }\n\n    private $typeCheck;\n    private $index;\n    private $collection;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,2,2,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,1,null,1,1,null,null,null,null,null,null,1,null,1,1,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null]},{"name":"Icecave\/Collections\/Iterator\/SequentialKeyIterator.php","source":"<?php\nnamespace Icecave\\Collections\\Iterator;\n\nuse Icecave\\Collections\\TypeCheck\\TypeCheck;\nuse IteratorIterator;\nuse Traversable;\n\n\/**\n * Wraps a traversable in an iterator that yields an integer key.\n *\n * It is guaranteed that the internal iterator's key() method is never called.\n *\/\nclass SequentialKeyIterator extends IteratorIterator\n{\n    \/**\n     * @param Traversable $iterator The collection to be iterated.\n     *\/\n    public function __construct(Traversable $iterator)\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n\n        parent::__construct($iterator);\n\n        $this->index = 0;\n    }\n\n    \/**\n     * Fetch the current key.\n     *\n     * @return integer The current key.\n     *\/\n    public function key()\n    {\n        $this->typeCheck->key(func_get_args());\n\n        return $this->index;\n    }\n\n    \/**\n     * Advance to the next element.\n     *\/\n    public function next()\n    {\n        $this->typeCheck->next(func_get_args());\n\n        ++$this->index;\n        parent::next();\n    }\n\n    \/**\n     * Rewind to the first element.\n     *\/\n    public function rewind()\n    {\n        $this->typeCheck->rewind(func_get_args());\n\n        $this->index = 0;\n        parent::rewind();\n    }\n\n    private $typeCheck;\n    private $index;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,1,1,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,1,null,1,1,1,null,null,null,null,null,null,1,null,1,1,1,null,null,null,null]},{"name":"Icecave\/Collections\/Iterator\/Traits.php","source":"<?php\nnamespace Icecave\\Collections\\Iterator;\n\nuse Icecave\\Collections\\TypeCheck\\TypeCheck;\n\n\/**\n * Describes the traits and capabilities of an iterator.\n *\/\nfinal class Traits\n{\n    \/**\n     * @param boolean $isCountable  True if the iterator can be counted without iteration.\n     * @param boolean $isRewindable True if the iterator can be rewound and re-iterated.\n     *\/\n    public function __construct(\n        $isCountable,\n        $isRewindable\n    ) {\n        TypeCheck::get(__CLASS__, func_get_args());\n\n        $this->isCountable = $isCountable;\n        $this->isRewindable = $isRewindable;\n    }\n    \/**\n     * @var boolean True if the iterator can be counted without iteration.\n     *\/\n    public $isCountable;\n\n    \/**\n     * @var boolean True if the iterator can be rewound and re-iterated.\n     *\/\n    public $isRewindable;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,null,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Collections\/Iterator\/TraitsProviderInterface.php","source":"<?php\nnamespace Icecave\\Collections\\Iterator;\n\ninterface TraitsProviderInterface\n{\n    \/**\n     * Return traits describing the collection's iteration capabilities.\n     *\n     * @return Traits\n     *\/\n    public function iteratorTraits();\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Collections\/LinkedList.php","source":"<?php\nnamespace Icecave\\Collections;\n\nuse Countable;\nuse Icecave\\Collections\\Iterator\\Traits;\nuse Icecave\\Collections\\TypeCheck\\TypeCheck;\nuse Iterator;\nuse Serializable;\nuse stdClass;\n\n\/**\n * A mutable sequence with efficient addition and removal of elements.\n *\/\nclass LinkedList implements MutableRandomAccessInterface, Countable, Iterator, Serializable\n{\n    \/**\n     * @param mixed<mixed>|null $collection An iterable type containing the elements to include in this list, or null to create an empty list.\n     *\/\n    public function __construct($collection = null)\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n\n        $this->clear();\n\n        if (null !== $collection) {\n            $this->insertMany(0, $collection);\n        }\n    }\n\n    public function __clone()\n    {\n        $this->typeCheck->validateClone(func_get_args());\n\n        $node = $this->head;\n        $prev = null;\n\n        while ($node) {\n\n            \/\/ Clone the node ...\n            $newNode = clone $node;\n\n            \/\/ If there was a previous node, create the link ...\n            if ($prev) {\n                $prev->next = $newNode;\n\n            \/\/ Otherwise this must be the head ...\n            } else {\n                $this->head = $newNode;\n            }\n\n            \/\/ This node is the current node of iteration ...\n            if ($node === $this->currentNode) {\n                $this->currentNode = $newNode;\n            }\n\n            $prev = $node;\n            $node = $node->next;\n        }\n\n        $this->tail = $prev;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of CollectionInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Fetch the number of elements in the collection.\n     *\n     * @see CollectionInterface::isEmpty()\n     *\n     * @return integer The number of elements in the collection.\n     *\/\n    public function size()\n    {\n        $this->typeCheck->size(func_get_args());\n\n        return $this->size;\n    }\n\n    \/**\n     * Check if the collection is empty.\n     *\n     * @return boolean True if the collection is empty; otherwise, false.\n     *\/\n    public function isEmpty()\n    {\n        $this->typeCheck->isEmpty(func_get_args());\n\n        return null === $this->head;\n    }\n\n    \/**\n     * Fetch a string representation of the collection.\n     *\n     * The string may not describe all elements of the collection, but should at least\n     * provide information on the type and state of the collection.\n     *\n     * @return string A string representation of the collection.\n     *\/\n    public function __toString()\n    {\n        if ($this->isEmpty()) {\n            return '<LinkedList 0>';\n        }\n\n        $elements = $this\n            ->slice(0, 3)\n            ->map('Icecave\\Repr\\Repr::repr');\n\n        if ($this->size > 3) {\n            $format = '<LinkedList %d [%s, ...]>';\n        } else {\n            $format = '<LinkedList %d [%s]>';\n        }\n\n        return sprintf(\n            $format,\n            $this->size,\n            implode(', ', $elements->elements())\n        );\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of MutableCollectionInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Remove all elements from the collection.\n     *\/\n    public function clear()\n    {\n        $this->typeCheck->clear(func_get_args());\n\n        $this->head = null;\n        $this->tail = null;\n        $this->size = 0;\n\n        $this->currentNode = null;\n        $this->currentIndex = 0;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of IteratorTraitsProvider \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Return traits describing the collection's iteration capabilities.\n     *\n     * @return Traits\n     *\/\n    public function iteratorTraits()\n    {\n        $this->typeCheck->iteratorTraits(func_get_args());\n\n        return new Traits(true, true);\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of IterableInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Fetch a native array containing the elements in the collection.\n     *\n     * @return array An array containing the elements in the collection.\n     *\/\n    public function elements()\n    {\n        $this->typeCheck->elements(func_get_args());\n\n        $elements = array();\n\n        for ($node = $this->head; null !== $node; $node = $node->next) {\n            $elements[] = $node->element;\n        }\n\n        return $elements;\n    }\n\n    \/**\n     * Check if the collection contains an element.\n     *\n     * @param mixed $element The element to check.\n     *\n     * @return boolean True if the collection contains $element; otherwise, false.\n     *\/\n    public function contains($element)\n    {\n        $this->typeCheck->contains(func_get_args());\n\n        for ($node = $this->head; null !== $node; $node = $node->next) {\n            if ($element === $node->element) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    \/**\n     * Fetch a new collection with a subset of the elements from this collection.\n     *\n     * @param callable|null $predicate A predicate function used to determine which elements to include, or null to include all non-null elements.\n     *\n     * @return LinkedList The filtered collection.\n     *\/\n    public function filter($predicate = null)\n    {\n        $this->typeCheck->filter(func_get_args());\n\n        if (null === $predicate) {\n            $predicate = function ($element) {\n                return null !== $element;\n            };\n        }\n\n        $result = new static;\n\n        for ($node = $this->head; null !== $node; $node = $node->next) {\n            if (call_user_func($predicate, $node->element)) {\n                $result->pushBack($node->element);\n            }\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Produce a new collection by applying a transformation to each element.\n     *\n     * The new elements produced by the transform need not be of the same type.\n     * It is not guaranteed that the concrete type of the resulting collection will match this collection.\n     *\n     * @param callable $transform The transform to apply to each element.\n     *\n     * @return IterableInterface A new collection produced by applying $transform to each element in this collection.\n     *\/\n    public function map($transform)\n    {\n        $this->typeCheck->map(func_get_args());\n\n        $result = new static;\n\n        for ($node = $this->head; null !== $node; $node = $node->next) {\n            $result->pushBack(call_user_func($transform, $node->element));\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Partitions this collection into two collections according to a predicate.\n     *\n     * It is not guaranteed that the concrete type of the partitioned collections will match this collection.\n     *\n     * @param callable $predicate A predicate function used to determine which partitioned collection to place the elements in.\n     *\n     * @return tuple<IterableInterface,IterableInterface> A 2-tuple containing the partitioned collections. The first collection contains the element for which the predicate returned true.\n     *\/\n    public function partition($predicate)\n    {\n        $this->typeCheck->partition(func_get_args());\n\n        $left = new static;\n        $right = new static;\n\n        for ($node = $this->head; null !== $node; $node = $node->next) {\n            if (call_user_func($predicate, $node->element)) {\n                $left->pushBack($node->element);\n            } else {\n                $right->pushBack($node->element);\n            }\n        }\n\n        return array($left, $right);\n    }\n\n    \/**\n     * Invokes the given callback on every element in the collection.\n     *\n     * This method behaves the same as {@see IterableInterface::map()} except that the return value of the callback is not retained.\n     *\n     * @param callable $callback The callback to invoke with each element.\n     *\/\n    public function each($callback)\n    {\n        $this->typeCheck->each(func_get_args());\n\n        for ($node = $this->head; null !== $node; $node = $node->next) {\n            call_user_func($callback, $node->element);\n        }\n    }\n\n    \/**\n     * Returns true if the given predicate returns true for all elements.\n     *\n     * The loop is short-circuited, exiting after the first element for which the predicate returns false.\n     *\n     * @param callable $predicate\n     *\n     * @return boolean True if $predicate($element) returns true for all elements; otherwise, false.\n     *\/\n    public function all($predicate)\n    {\n        $this->typeCheck->all(func_get_args());\n\n        for ($node = $this->head; null !== $node; $node = $node->next) {\n            if (!call_user_func($predicate, $node->element)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \/**\n     * Returns true if the given predicate returns true for any element.\n     *\n     * The loop is short-circuited, exiting after the first element for which the predicate returns false.\n     *\n     * @param callable $predicate\n     *\n     * @return boolean True if $predicate($element) returns true for any element; otherwise, false.\n     *\/\n    public function any($predicate)\n    {\n        $this->typeCheck->any(func_get_args());\n\n        for ($node = $this->head; null !== $node; $node = $node->next) {\n            if (call_user_func($predicate, $node->element)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of MutableIterableInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Filter this collection in-place.\n     *\n     * @param callable|null $predicate A predicate function used to determine which elements to retain, or null to retain all non-null elements.\n     *\/\n    public function filterInPlace($predicate = null)\n    {\n        $this->typeCheck->filterInPlace(func_get_args());\n\n        if (null === $predicate) {\n            $predicate = function ($element) {\n                return null !== $element;\n            };\n        }\n\n        $node = $this->head;\n        $prev = null;\n\n        while ($node) {\n\n            \/\/ Keep the node ...\n            if (call_user_func($predicate, $node->element)) {\n                $prev = $node;\n            \/\/ Don't keep the node, and it's the first one ...\n            } elseif (null === $prev) {\n                $this->head = $node->next;\n                --$this->size;\n            \/\/ Don't keep the node ...\n            } else {\n                $prev->next = $node->next;\n                --$this->size;\n            }\n\n            $node = $node->next;\n        }\n\n        $this->tail = $prev;\n    }\n\n    \/**\n     * Replace each element in the collection with the result of a transformation on that element.\n     *\n     * The new elements produced by the transform must be the same type.\n     *\n     * @param callable $transform The transform to apply to each element.\n     *\/\n    public function mapInPlace($transform)\n    {\n        $this->typeCheck->mapInPlace(func_get_args());\n\n        for ($node = $this->head; null !== $node; $node = $node->next) {\n            $node->element = call_user_func($transform, $node->element);\n        }\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of SequenceInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Fetch the first element in the sequence.\n     *\n     * @return mixed                              The first element in the sequence.\n     * @throws Exception\\EmptyCollectionException if the collection is empty.\n     *\/\n    public function front()\n    {\n        $this->typeCheck->front(func_get_args());\n\n        if ($this->isEmpty()) {\n            throw new Exception\\EmptyCollectionException;\n        }\n\n        return $this->head->element;\n    }\n\n    \/**\n     * Fetch the first element in the sequence.\n     *\n     * @param mixed &$element Assigned the element at the front of collection.\n     *\n     * @return boolean True is the element exists and was assigned to $element; otherwise, false.\n     *\/\n    public function tryFront(&$element)\n    {\n        $this->typeCheck->tryFront(func_get_args());\n\n        if ($this->isEmpty()) {\n            return false;\n        }\n\n        $element = $this->head->element;\n\n        return true;\n    }\n\n    \/**\n     * Fetch the last element in the sequence.\n     *\n     * @return mixed                              The first element in the sequence.\n     * @throws Exception\\EmptyCollectionException if the collection is empty.\n     *\/\n    public function back()\n    {\n        $this->typeCheck->back(func_get_args());\n\n        if ($this->isEmpty()) {\n            throw new Exception\\EmptyCollectionException;\n        }\n\n        return $this->tail->element;\n    }\n\n    \/**\n     * Fetch the last element in the sequence.\n     *\n     * @param mixed &$element Assigned the element at the front of collection.\n     *\n     * @return boolean True is the element exists and was assigned to $element; otherwise, false.\n     *\/\n    public function tryBack(&$element)\n    {\n        $this->typeCheck->tryBack(func_get_args());\n\n        if ($this->isEmpty()) {\n            return false;\n        }\n\n        $element = $this->tail->element;\n\n        return true;\n    }\n\n    \/**\n     * Create a new sequence with the elements from this sequence in sorted order.\n     *\n     * @param callable|null $comparator A strcmp style comparator function.\n     *\n     * @return LinkedList\n     *\/\n    public function sort($comparator = null)\n    {\n        $this->typeCheck->sort(func_get_args());\n\n        $result = clone $this;\n        $result->sortInPlace($comparator);\n\n        return $result;\n    }\n\n    \/**\n     * Create a new sequence with the elements from this sequence in reverse order.\n     *\n     * It is not guaranteed that the concrete type of the reversed collection will match this collection.\n     *\n     * @return LinkedList The reversed sequence.\n     *\/\n    public function reverse()\n    {\n        $this->typeCheck->reverse(func_get_args());\n\n        $result = new static;\n\n        for ($node = $this->head; null !== $node; $node = $node->next) {\n            $result->pushFront($node->element);\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Create a new sequence by appending the elements in the given sequence to this sequence.\n     *\n     * @param mixed<mixed> $sequence       The sequence to append.\n     * @param mixed<mixed> $additional,... Additional sequences to append.\n     *\n     * @return SequenceInterface A new sequence containing all elements from this sequence and $sequence.\n     *\/\n    public function join($sequence)\n    {\n        $this->typeCheck->join(func_get_args());\n\n        $result = new static;\n        list($result->head, $result->tail, $result->size) = $this->cloneNodes($this->head);\n\n        foreach (func_get_args() as $sequence) {\n            $result->insertMany($result->size, $sequence);\n        }\n\n        return $result;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of MutableSequenceInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Sort this sequence in-place.\n     *\n     * @link http:\/\/www.chiark.greenend.org.uk\/~sgtatham\/algorithms\/listsort.html\n     *\n     * @param callable|null $comparator A strcmp style comparator function.\n     *\/\n    public function sortInPlace($comparator = null)\n    {\n        $this->typeCheck->sortInPlace(func_get_args());\n\n        if ($this->size <= 1) {\n            return;\n        }\n\n        if (null === $comparator) {\n            $comparator = function ($a, $b) {\n                if ($a < $b) {\n                    return -1;\n                } elseif ($a > $b) {\n                    return 1;\n                } else {\n                    return 0;\n                }\n            };\n        }\n\n        $chunkSize = 1;\n\n        $left = null;\n        $head = $this->head;\n        $tail = null;\n\n        do {\n            $left = $head;\n            $head = null;\n            $tail = null;\n\n            $mergeCount = 0;\n\n            while ($left) {\n                ++$mergeCount;\n\n                $right = $left;\n\n                for ($leftSize = 0; $right && $leftSize < $chunkSize; ++$leftSize) {\n                    $right = $right->next;\n                }\n\n                $rightSize = $chunkSize;\n\n                while ($leftSize || ($right && $rightSize)) {\n                    if (0 === $leftSize) {\n                        $node = $right;\n                        $right = $right->next;\n                        --$rightSize;\n                    } elseif (!$right || 0 === $rightSize) {\n                        $node = $left;\n                        $left = $left->next;\n                        --$leftSize;\n                    } elseif (call_user_func($comparator, $left->element, $right->element) <= 0) {\n                        $node = $left;\n                        $left = $left->next;\n                        --$leftSize;\n                    } else {\n                        $node = $right;\n                        $right = $right->next;\n                        --$rightSize;\n                    }\n\n                    if ($tail) {\n                        $tail->next = $node;\n                    } else {\n                        $head = $node;\n                    }\n\n                    $tail = $node;\n                }\n\n                $left = $right;\n            }\n\n            $tail->next = null;\n            $chunkSize *= 2;\n\n        } while ($mergeCount > 1);\n\n        $this->head = $head;\n        $this->tail = $tail;\n        $this->rewind();\n    }\n\n    \/**\n     * Reverse this sequence in-place.\n     *\/\n    public function reverseInPlace()\n    {\n        $this->typeCheck->reverseInPlace(func_get_args());\n\n        $prev = null;\n        $node = $this->head;\n\n        while ($node) {\n            $next = $node->next;\n            $node->next = $prev;\n            $prev = $node;\n            $node = $next;\n        }\n\n        $head       = $this->head;\n        $this->head = $this->tail;\n        $this->tail = $head;\n    }\n\n    \/**\n     * Appending elements in the given sequence to this sequence.\n     *\n     * @param mixed<mixed> $sequence       The sequence to append.\n     * @param mixed<mixed> $additional,... Additional sequences to append.\n     *\/\n    public function append($sequence)\n    {\n        $this->typeCheck->append(func_get_args());\n\n        foreach (func_get_args() as $sequence) {\n            $this->insertMany($this->size, $sequence);\n        }\n    }\n\n    \/**\n     * Add a new element to the front of the sequence.\n     *\n     * @param mixed $element The element to prepend.\n     *\/\n    public function pushFront($element)\n    {\n        $this->typeCheck->pushFront(func_get_args());\n\n        $this->head = $this->createNode($element, $this->head);\n\n        if (0 === $this->size++) {\n            $this->tail = $this->head;\n        }\n    }\n\n    \/**\n     * Remove and return the element at the front of the sequence.\n     *\n     * @return mixed                              The element at the front of the sequence.\n     * @throws Exception\\EmptyCollectionException if the collection is empty.\n     *\/\n    public function popFront()\n    {\n        $this->typeCheck->popFront(func_get_args());\n\n        if ($this->isEmpty()) {\n            throw new Exception\\EmptyCollectionException;\n        }\n\n        $element    = $this->head->element;\n        $this->head = $this->head->next;\n\n        if (0 === --$this->size) {\n            $this->tail = null;\n        }\n\n        return $element;\n    }\n\n    \/**\n     * Remove the element at the front of the sequence.\n     *\n     * @param mixed &$element Assigned the removed element.\n     *\n     * @return boolean True if the front element is removed and assigned to $element; otherwise, false.\n     *\/\n    public function tryPopFront(&$element = null)\n    {\n        $this->typeCheck->tryPopFront(func_get_args());\n\n        if ($this->isEmpty()) {\n            return false;\n        }\n\n        $element = $this->popFront();\n\n        return true;\n    }\n\n    \/**\n     * Add a new element to the back of the sequence.\n     *\n     * @param mixed $element The element to append.\n     *\/\n    public function pushBack($element)\n    {\n        $this->typeCheck->pushBack(func_get_args());\n\n        $node = $this->createNode($element);\n\n        if (0 === $this->size++) {\n            $this->head = $node;\n        } else {\n            $this->tail->next = $node;\n        }\n\n        $this->tail = $node;\n    }\n\n    \/**\n     * Remove and return the element at the back of the sequence.\n     *\n     * @return mixed                              The element at the back of the sequence.\n     * @throws Exception\\EmptyCollectionException if the collection is empty.\n     *\/\n    public function popBack()\n    {\n        $this->typeCheck->popBack(func_get_args());\n\n        if ($this->isEmpty()) {\n            throw new Exception\\EmptyCollectionException;\n        }\n\n        $element = $this->tail->element;\n\n        if (0 === --$this->size) {\n            $this->head = null;\n            $this->tail = null;\n        } else {\n            $this->tail = $this->nodeAt($this->size - 1);\n            $this->tail->next = null;\n        }\n\n        return $element;\n    }\n\n    \/**\n     * Remove the element at the back of the sequence.\n     *\n     * @param mixed &$element Assigned the removed element.\n     *\n     * @return boolean True if the back element is removed and assigned to $element; otherwise, false.\n     *\/\n    public function tryPopBack(&$element = null)\n    {\n        $this->typeCheck->tryPopBack(func_get_args());\n\n        if ($this->isEmpty()) {\n            return false;\n        }\n\n        $element = $this->popBack();\n\n        return true;\n    }\n\n    \/**\n     * Resize the sequence.\n     *\n     * @param integer $size    The new size of the collection.\n     * @param mixed   $element The value to use for populating new elements when $size > $this->size().\n     *\/\n    public function resize($size, $element = null)\n    {\n        $this->typeCheck->resize(func_get_args());\n\n        if ($this->size > $size) {\n            $this->removeMany($size);\n        } else {\n            while ($size--) {\n                $this->pushBack($element);\n            }\n        }\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of RandomAccessInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Fetch the element at the given index.\n     *\n     * @param mixed $index The index of the element to fetch, if index is a negative number the element that far from the end of the sequence is returned.\n     *\n     * @return mixed                    The element at $index.\n     * @throws Exception\\IndexException if $index is out of range.\n     *\/\n    public function get($index)\n    {\n        $this->typeCheck->get(func_get_args());\n\n        $this->validateIndex($index);\n\n        return $this->nodeAt($index)->element;\n    }\n\n    \/**\n     * Extract a range of elements.\n     *\n     * It is not guaranteed that the concrete type of the slice collection will match this collection.\n     *\n     * @param integer      $index The index from which the slice will start. If index is a negative number the slice will begin that far from the end of the sequence.\n     * @param integer|null $count The maximum number of elements to include in the slice, or null to include all elements from $index to the end of the sequence.\n     *\n     * @return SequenceInterface        The sliced sequence.\n     * @throws Exception\\IndexException if $index is out of range.\n     *\/\n    public function slice($index, $count = null)\n    {\n        $this->typeCheck->slice(func_get_args());\n\n        $this->validateIndex($index);\n\n        $start = $this->nodeAt($index);\n\n        if (null === $count) {\n            $stop = null;\n        } else {\n            $count = max(0, min($this->size - $index, $count));\n            $stop = $this->nodeFrom($start, $count);\n        }\n\n        $result = new static;\n        list($result->head, $result->tail, $result->size) = $this->cloneNodes($start, $stop);\n\n        return $result;\n    }\n\n    \/**\n     * Extract a range of elements.\n     *\n     * It is not guaranteed that the concrete type of the slice collection will match this collection.\n     *\n     * Extracts all elements in the range [$begin, $end), i.e. $begin is inclusive, $end is exclusive.\n     *\n     * @param integer $begin The index from which the slice will start. If begin is a negative number the slice will begin that far from the end of the sequence.\n     * @param integer $end   The index at which the slice will end. If end is a negative number the slice will end that far from the end of the sequence.\n     *\n     * @return SequenceInterface        The sliced sequence.\n     * @throws Exception\\IndexException if $begin or $end is out of range.\n     *\/\n    public function range($begin, $end)\n    {\n        $this->typeCheck->range(func_get_args());\n\n        $this->validateIndex($begin);\n        $this->validateIndex($end, $this->size);\n\n        return $this->slice($begin, $end - $begin);\n    }\n\n    \/**\n     * Find the index of the first instance of a particular element in the sequence.\n     *\n     * @param mixed   $element    The element to search for.\n     * @param integer $startIndex The index to start searching from.\n     *\n     * @return integer|null             The index of the element, or null if is not present in the sequence.\n     * @throws Exception\\IndexException if $startIndex is out of range.\n     *\/\n    public function indexOf($element, $startIndex = 0)\n    {\n        $this->typeCheck->indexOf(func_get_args());\n\n        $predicate = function ($e) use ($element) {\n            return $element === $e;\n        };\n\n        return $this->find($predicate, $startIndex);\n    }\n\n    \/**\n     * Find the index of the last instance of a particular element in the sequence.\n     *\n     * @param mixed        $element    The element to search for.\n     * @param integer|null $startIndex The index to start searching from, or null to use the last index.\n     *\n     * @return integer|null             The index of the element, or null if is not present in the sequence.\n     * @throws Exception\\IndexException if $startIndex is out of range.\n     *\/\n    public function indexOfLast($element, $startIndex = null)\n    {\n        $this->typeCheck->indexOfLast(func_get_args());\n\n        $predicate = function ($e) use ($element) {\n            return $element === $e;\n        };\n\n        return $this->findLast($predicate, $startIndex);\n    }\n\n    \/**\n     * Find the index of the first instance of an element matching given criteria.\n     *\n     * @param callable $predicate  A predicate function used to determine which element constitutes a match.\n     * @param integer  $startIndex The index to start searching from.\n     *\n     * @return integer|null             The index of the element, or null if is not present in the sequence.\n     * @throws Exception\\IndexException if $startIndex is out of range.\n     *\/\n    public function find($predicate, $startIndex = 0)\n    {\n        $this->typeCheck->find(func_get_args());\n\n        if ($this->isEmpty()) {\n            return null;\n        }\n\n        $this->validateIndex($startIndex);\n\n        for ($index = 0, $node = $this->head; null !== $node; ++$index, $node = $node->next) {\n            if ($index >= $startIndex && call_user_func($predicate, $node->element)) {\n                return $index;\n            }\n        }\n\n        return null;\n    }\n\n    \/**\n     * Find the index of the last instance of an element matching given criteria.\n     *\n     * @param callable     $predicate  A predicate function used to determine which element constitutes a match.\n     * @param integer|null $startIndex The index to start searching from, or null to use the last index.\n     *\n     * @return integer|null             The index of the element, or null if is not present in the sequence.\n     * @throws Exception\\IndexException if $startIndex is out of range.\n     *\/\n    public function findLast($predicate, $startIndex = null)\n    {\n        $this->typeCheck->findLast(func_get_args());\n\n        if ($this->isEmpty()) {\n            return null;\n        } elseif (null === $startIndex) {\n            $startIndex = $this->size - 1;\n        }\n\n        $this->validateIndex($startIndex);\n\n        $lastIndex = null;\n\n        for ($index = 0, $node = $this->head; null !== $node && $index <= $startIndex; ++$index, $node = $node->next) {\n            if (call_user_func($predicate, $node->element)) {\n                $lastIndex = $index;\n            }\n        }\n\n        return $lastIndex;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of MutableRandomAccessInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Replace the element at a particular position in the sequence.\n     *\n     * @param integer $index   The index of the element to set, if index is a negative number the element that far from the end of the sequence is set.\n     * @param mixed   $element The element to set.\n     *\n     * @throws Exception\\IndexException if $index is out of range.\n     *\/\n    public function set($index, $element)\n    {\n        $this->typeCheck->set(func_get_args());\n\n        $this->validateIndex($index);\n\n        $this->nodeAt($index)->element = $element;\n    }\n\n    \/**\n     * Insert an element at a particular index.\n     *\n     * @param integer $index   The index at which the element is inserted, if index is a negative number the element is inserted that far from the end of the sequence.\n     * @param mixed   $element The element to insert.\n     *\n     * @throws Exception\\IndexException if $index is out of range.\n     *\/\n    public function insert($index, $element)\n    {\n        $this->typeCheck->insert(func_get_args());\n\n        $this->insertMany($index, array($element));\n    }\n\n    \/**\n     * Insert a range of elements at a particular index.\n     *\n     * @param integer      $index    The index at which the elements are inserted, if index is a negative number the elements are inserted that far from the end of the sequence.\n     * @param mixed<mixed> $elements The elements to insert.\n     *\/\n    public function insertMany($index, $elements)\n    {\n        $this->typeCheck->insertMany(func_get_args());\n\n        $this->validateIndex($index, $this->size);\n\n        list($head, $tail, $size) = $this->createNodes($elements);\n\n        if (null === $head) {\n            return;\n        } elseif (0 === $this->size) {\n            $this->head = $head;\n            $this->tail = $tail;\n        } elseif (0 === $index) {\n            $tail->next = $this->head;\n            $this->head = $head;\n        } elseif ($this->size === $index) {\n            $this->tail->next = $head;\n            $this->tail = $tail;\n        } else {\n            $node = $this->nodeAt($index - 1);\n            $tail->next = $node->next;\n            $node->next = $head;\n        }\n\n        $this->size += $size;\n    }\n\n    \/**\n     * Remove the element at a given index.\n     *\n     * Elements after the given endex are moved forward by one.\n     *\n     * @param integer $index The index of the element to remove, if index is a negative number the element that far from the end of the sequence is removed.\n     *\n     * @throws Exception\\IndexException if $index is out of range.\n     *\/\n    public function remove($index)\n    {\n        $this->typeCheck->remove(func_get_args());\n\n        $this->removeRange($index, $index + 1);\n    }\n\n    \/**\n     * Remove a range of elements at a given index.\n     *\n     * @param integer      $index The index of the first element to remove, if index is a negative number the removal begins that far from the end of the sequence.\n     * @param integer|null $count The number of elements to remove, or null to remove all elements up to the end of the sequence.\n     *\n     * @throws Exception\\IndexException if $index is out of range.\n     *\/\n    public function removeMany($index, $count = null)\n    {\n        $this->typeCheck->removeMany(func_get_args());\n\n        $this->validateIndex($index);\n\n        \/\/ Remove, but not all the way to the end ...\n        if (null !== $count && $count < $this->size - $index) {\n            $count = max(0, $count);\n            $node = $this->nodeAt($index - 1);\n            $node->next = $this->nodeFrom($node, $count + 1);\n            $this->size -= $count;\n\n        \/\/ Remove everything ...\n        } elseif (0 === $index) {\n            $this->clear();\n\n        \/\/ Remove everything to the end ...\n        } else {\n            $node = $this->nodeAt($index - 1);\n            $node->next = null;\n            $this->tail = $node;\n            $this->size = $index;\n        }\n    }\n\n    \/**\n     * Remove a range of elements at a given index.\n     *\n     * Removes all elements in the range [$begin, $end), i.e. $begin is inclusive, $end is exclusive.\n     *\n     * @param integer $begin The index of the first element to remove, if $begin is a negative number the removal begins that far from the end of the sequence.\n     * @param integer $end   The index of the last element to remove, if $end is a negative number the removal ends that far from the end of the sequence.\n     *\n     * @throws Exception\\IndexException if $begin or $end is out of range.\n     *\/\n    public function removeRange($begin, $end)\n    {\n        $this->typeCheck->removeRange(func_get_args());\n\n        $this->validateIndex($begin);\n        $this->validateIndex($end, $this->size);\n\n        $this->removeMany($begin, $end - $begin);\n    }\n\n    \/**\n     * Replace a range of elements with a second set of elements.\n     *\n     * Replaces all elements in the range [$begin, $end), i.e. $begin is inclusive, $end is exclusive.\n     *\n     * @param integer      $index    The index of the first element to replace, if index is a negative number the replace begins that far from the end of the sequence.\n     * @param mixed<mixed> $elements The elements to insert.\n     * @param integer|null $count    The number of elements to replace, or null to replace all elements up to the end of the sequence.\n     *\/\n    public function replace($index, $elements, $count = null)\n    {\n        $this->typeCheck->replace(func_get_args());\n\n        $this->validateIndex($index);\n\n        $this->removeMany($index, $count);\n        $this->insertMany($index, $elements);\n    }\n\n    \/**\n     * Replace a range of elements with a second set of elements.\n     *\n     * @param integer      $begin    The index of the first element to replace, if begin is a negative number the replace begins that far from the end of the sequence.\n     * @param integer      $end      The index of the last element to replace, if end is a negativ enumber the replace ends that far from the end of the sequence.\n     * @param mixed<mixed> $elements The elements to insert.\n     *\/\n    public function replaceRange($begin, $end, $elements)\n    {\n        $this->typeCheck->replaceRange(func_get_args());\n\n        $this->validateIndex($begin);\n\n        $this->removeRange($begin, $end);\n        $this->insertMany($begin, $elements);\n    }\n\n    \/**\n     * Swap the elements at two index positions.\n     *\n     * @param integer $index1 The index of the first element.\n     * @param integer $index2 The index of the second element.\n     *\n     * @throws Exception\\IndexException if $index1 or $index2 is out of range.\n     *\/\n    public function swap($index1, $index2)\n    {\n        $this->typeCheck->swap(func_get_args());\n\n        $this->validateIndex($index1);\n        $this->validateIndex($index2);\n\n        $this->doSwap($index1, $index2);\n    }\n\n    \/**\n     * Swap the elements at two index positions.\n     *\n     * @param integer $index1 The index of the first element.\n     * @param integer $index2 The index of the second element.\n     *\n     * @return boolean True if $index1 and $index2 are in range and the swap is successful.\n     *\/\n    public function trySwap($index1, $index2)\n    {\n        $this->typeCheck->trySwap(func_get_args());\n\n        if ($index1 < 0) {\n            $index1 += $this->size();\n        }\n\n        if ($index2 < 0) {\n            $index2 += $this->size();\n        }\n\n        if ($index1 < 0 || $index1 >= $this->size()) {\n            return false;\n        }\n\n        if ($index2 < 0 || $index2 >= $this->size()) {\n            return false;\n        }\n\n        $this->doSwap($index1, $index2);\n\n        return true;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of Countable \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    public function count()\n    {\n        $this->typeCheck->count(func_get_args());\n\n        return $this->size();\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of Iterator \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    public function current()\n    {\n        $this->typeCheck->current(func_get_args());\n\n        return $this->currentNode->element;\n    }\n\n    public function key()\n    {\n        $this->typeCheck->key(func_get_args());\n\n        return $this->currentIndex;\n    }\n\n    public function next()\n    {\n        $this->typeCheck->next(func_get_args());\n\n        $this->currentNode = $this->currentNode->next;\n        ++$this->currentIndex;\n    }\n\n    public function rewind()\n    {\n        $this->typeCheck->rewind(func_get_args());\n\n        $this->currentNode = $this->head;\n        $this->currentIndex = 0;\n    }\n\n    public function valid()\n    {\n        $this->typeCheck->valid(func_get_args());\n\n        return null !== $this->currentNode;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of Serializable \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Serialize the collection.\n     *\n     * @return string The serialized data.\n     *\/\n    public function serialize()\n    {\n        $this->typeCheck->serialize(func_get_args());\n\n        return serialize(\n            array(\n                $this->currentIndex,\n                $this->elements()\n            )\n        );\n    }\n\n    \/**\n     * Unserialize collection data.\n     *\n     * @param string $packet The serialized data.\n     *\/\n    public function unserialize($packet)\n    {\n        TypeCheck::get(__CLASS__)->unserialize(func_get_args());\n\n        list($currentIndex, $elements) = unserialize($packet);\n        $this->__construct($elements);\n        $this->currentNode = $this->nodeFrom($this->head, $currentIndex);\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Model specific methods \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * @param integer $index1\n     * @param integer $index2\n     *\/\n    private function doSwap($index1, $index2)\n    {\n        $a = min($index1, $index2);\n        $b = max($index1, $index2);\n\n        $node1 = $this->nodeAt($a);\n        $node2 = $this->nodeFrom($node1, $b - $a);\n\n        $element        = $node1->element;\n        $node1->element = $node2->element;\n        $node2->element = $element;\n    }\n\n    \/**\n     * @param integer      &$index\n     * @param integer|null $max\n     *\/\n    private function validateIndex(&$index, $max = null)\n    {\n        if (null === $max) {\n            $max = $this->size - 1;\n        }\n\n        if ($index < 0) {\n            $index += $this->size;\n        }\n\n        if ($index < 0 || $index > $max) {\n            throw new Exception\\IndexException($index);\n        }\n    }\n\n    \/**\n     * @param mixed         $element\n     * @param stdClass|null $next\n     *\/\n    private function createNode($element = null, stdClass $next = null)\n    {\n        $node = new stdClass;\n        $node->next = $next;\n        $node->element = $element;\n\n        return $node;\n    }\n\n    \/**\n     * @param integer $index\n     *\/\n    private function nodeAt($index)\n    {\n        return $this->nodeFrom($this->head, $index);\n    }\n\n    \/**\n     * @param stdClass $node\n     * @param integer  $count\n     *\/\n    private function nodeFrom(stdClass $node, $count)\n    {\n        while ($node && $count--) {\n            $node = $node->next;\n        }\n\n        return $node;\n    }\n\n    \/**\n     * @param stdClass      $start\n     * @param stdClass|null $stop\n     *\/\n    private function cloneNodes(stdClass $start, stdClass $stop = null)\n    {\n        $head = null;\n        $tail = null;\n        $size = 0;\n\n        for ($node = $start; $stop !== $node; $node = $node->next) {\n            $n = $this->createNode($node->element);\n            if (null === $head) {\n                $head = $n;\n            } else {\n                $tail->next = $n;\n            }\n            $tail = $n;\n            ++$size;\n        }\n\n        return array($head, $tail, $size);\n    }\n\n    \/**\n     * @param mixed<mixed> $elements\n     *\/\n    private function createNodes($elements)\n    {\n        $head = null;\n        $tail = null;\n        $size = 0;\n\n        foreach ($elements as $element) {\n            $node = $this->createNode($element);\n            if (null === $head) {\n                $head = $node;\n            } else {\n                $tail->next = $node;\n            }\n            $tail = $node;\n            ++$size;\n        }\n\n        return array($head, $tail, $size);\n    }\n\n    private $typeCheck;\n    private $head;\n    private $tail;\n    private $size;\n    private $currentNode;\n    private $currentIndex;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,119,null,119,null,119,2,2,119,null,null,null,3,null,3,3,null,3,null,null,3,null,null,3,3,null,null,3,3,null,null,null,3,1,1,null,3,3,3,null,3,3,null,null,null,null,null,null,null,null,null,null,null,null,null,null,119,null,119,null,null,null,null,null,null,null,null,null,30,null,30,null,null,null,null,null,null,null,null,null,null,null,null,1,1,null,null,1,1,1,null,1,1,1,1,null,null,1,1,1,1,1,null,null,null,null,null,null,null,null,null,null,null,119,null,119,119,119,null,119,119,119,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,119,null,119,null,119,90,90,null,119,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,2,null,2,1,1,1,1,null,2,null,2,2,2,2,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,2,2,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,null,1,1,1,1,1,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,1,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,1,1,1,1,null,2,2,null,2,null,null,2,2,null,2,1,1,null,1,2,2,null,null,2,2,null,2,2,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,1,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,1,null,null,1,null,null,null,null,null,null,null,null,null,null,null,2,null,2,1,null,null,1,null,1,null,null,null,null,null,null,null,null,null,null,2,null,2,1,null,null,1,null,null,null,null,null,null,null,null,null,null,null,2,null,2,1,null,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,2,null,2,2,null,2,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,1,1,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,null,1,1,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,6,null,6,2,null,null,4,2,2,2,2,2,null,1,null,2,2,null,4,null,4,4,4,null,null,4,4,4,null,4,null,4,4,null,4,null,4,4,4,null,4,null,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,null,null,4,4,4,4,null,null,4,4,null,4,4,null,4,4,null,4,null,4,4,4,4,null,null,null,null,null,null,1,null,1,1,null,1,1,1,1,1,1,null,1,1,1,1,null,null,null,null,null,null,null,null,null,80,null,80,80,80,80,null,null,null,null,null,null,null,null,2,null,2,null,2,2,2,2,null,null,null,null,null,null,null,null,null,4,null,4,1,null,null,3,3,null,3,1,1,null,3,null,null,null,null,null,null,null,null,null,null,null,2,null,2,1,null,null,1,null,1,null,null,null,null,null,null,null,null,null,19,null,19,null,19,19,19,14,null,null,19,19,null,null,null,null,null,null,null,null,null,5,null,5,1,null,null,4,null,4,1,1,1,3,3,null,null,4,null,null,null,null,null,null,null,null,null,null,null,2,null,2,1,null,null,1,null,1,null,null,null,null,null,null,null,null,null,null,3,null,3,1,1,2,2,2,null,3,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,3,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,9,null,9,null,9,null,9,2,2,7,7,null,null,9,9,null,9,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,3,3,null,3,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,null,3,3,null,3,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,null,3,3,null,3,null,null,null,null,null,null,null,null,null,null,null,null,null,4,null,4,1,null,null,4,null,4,4,3,null,4,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,4,null,4,1,4,3,3,null,4,null,4,null,4,4,3,3,4,null,4,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,3,null,2,2,null,null,null,null,null,null,null,null,null,null,null,4,null,4,3,null,null,null,null,null,null,null,null,null,84,null,84,null,82,null,82,1,82,82,82,82,1,1,18,7,7,7,10,10,10,null,null,82,82,null,null,null,null,null,null,null,null,null,null,null,null,3,null,3,2,null,null,null,null,null,null,null,null,null,null,null,20,null,20,null,null,19,14,14,14,14,null,null,19,1,null,null,1,4,4,4,4,null,19,null,null,null,null,null,null,null,null,null,null,null,null,null,12,null,12,10,null,10,10,null,null,null,null,null,null,null,null,null,null,null,null,4,null,4,null,3,3,3,null,null,null,null,null,null,null,null,null,null,5,null,5,null,4,4,4,null,null,null,null,null,null,null,null,null,null,null,4,null,4,3,null,2,2,null,null,null,null,null,null,null,null,null,null,null,4,null,4,1,1,null,4,1,1,null,4,1,null,null,3,1,null,null,2,null,2,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,2,null,2,null,null,null,null,1,null,1,null,null,null,null,2,null,2,2,2,null,null,null,6,null,6,6,6,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,1,1,1,1,null,null,null,null,null,null,null,null,null,1,null,1,1,1,1,null,null,null,null,null,null,null,null,null,null,null,4,4,null,4,4,null,4,4,4,4,null,null,null,null,null,null,null,95,51,51,null,95,13,13,null,95,11,null,85,null,null,null,null,null,null,null,97,97,97,null,97,null,null,null,null,null,null,null,42,null,null,null,null,null,null,null,null,43,35,35,null,43,null,null,null,null,null,null,null,null,10,10,10,null,10,8,8,8,8,8,null,8,8,8,null,10,null,null,null,null,null,null,null,82,82,82,null,82,82,82,82,82,80,null,82,82,82,null,82,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Collections\/Map.php","source":"<?php\nnamespace Icecave\\Collections;\n\nuse ArrayAccess;\nuse Countable;\nuse Icecave\\Collections\\Iterator\\Traits;\nuse Icecave\\Collections\\TypeCheck\\TypeCheck;\nuse Icecave\\Repr\\Repr;\nuse Iterator;\nuse Serializable;\n\n\/**\n * An associative collection with efficient access by key.\n *\/\nclass Map implements MutableAssociativeInterface, Countable, Iterator, ArrayAccess, Serializable\n{\n    \/**\n     * @param mixed<mixed>|null $collection   An iterable type containing the elements to include in this map, or null to create an empty map.\n     * @param callable|null     $hashFunction The function to use for generating hashes of element values, or null to use the default.\n     *\/\n    public function __construct($collection = null, $hashFunction = null)\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n\n        if (null === $hashFunction) {\n            $hashFunction = new Utility\\AssociativeKeyGenerator;\n        }\n\n        $this->hashFunction = $hashFunction;\n        $this->elements = array();\n\n        if (null !== $collection) {\n            foreach ($collection as $key => $value) {\n                $this->set($key, $value);\n            }\n        }\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of CollectionInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Fetch the number of elements in the collection.\n     *\n     * @see Map::isEmpty()\n     *\n     * @return integer The number of elements in the collection.\n     *\/\n    public function size()\n    {\n        $this->typeCheck->size(func_get_args());\n\n        return count($this->elements);\n    }\n\n    \/**\n     * Check if the collection is empty.\n     *\n     * @return boolean True if the collection is empty; otherwise, false.\n     *\/\n    public function isEmpty()\n    {\n        $this->typeCheck->isEmpty(func_get_args());\n\n        return empty($this->elements);\n    }\n\n    \/**\n     * Fetch a string representation of the collection.\n     *\n     * The string may not describe all elements of the collection, but should at least\n     * provide information on the type and state of the collection.\n     *\n     * @return string A string representation of the collection.\n     *\/\n    public function __toString()\n    {\n        if ($this->isEmpty()) {\n            return '<Map 0>';\n        }\n\n        $elements = array();\n        $index = 0;\n        foreach ($this->elements as $element) {\n            if ($index++ === 3) {\n                break;\n            }\n\n            list($key, $value) = $element;\n\n            $elements[] = Repr::repr($key) . ' => ' . Repr::repr($value);\n        }\n\n        if ($this->size() > 3) {\n            $format = '<Map %d [%s, ...]>';\n        } else {\n            $format = '<Map %d [%s]>';\n        }\n\n        return sprintf(\n            $format,\n            $this->size(),\n            implode(', ', $elements)\n        );\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of MutableCollectionInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Remove all elements from the collection.\n     *\/\n    public function clear()\n    {\n        $this->typeCheck->clear(func_get_args());\n\n        $this->elements = array();\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of IteratorTraitsProvider \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Return traits describing the collection's iteration capabilities.\n     *\n     * @return Traits\n     *\/\n    public function iteratorTraits()\n    {\n        $this->typeCheck->iteratorTraits(func_get_args());\n\n        return new Traits(true, true);\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of IterableInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Fetch a native array containing the elements in the collection.\n     *\n     * @return array An array containing the elements in the collection.\n     *\/\n    public function elements()\n    {\n        $this->typeCheck->elements(func_get_args());\n\n        return array_values($this->elements);\n    }\n\n    \/**\n     * Check if the collection contains an element with the given value.\n     *\n     * @param mixed $value The value to check.\n     *\n     * @return boolean True if the collection contains $value; otherwise, false.\n     *\/\n    public function contains($value)\n    {\n        $this->typeCheck->contains(func_get_args());\n\n        foreach ($this->elements as $element) {\n            list(, $v) = $element;\n            if ($v === $value) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    \/**\n     * Fetch a new collection with a subset of the elements from this collection.\n     *\n     * The predicate must be a callable with the following signature:\n     *  function (mixed $key, mixed $value) { return $true_to_retain_element; }\n     *\n     * @param callable|null $predicate A predicate function used to determine which elements to include, or null to include all elements with non-null values.\n     *\n     * @return Map The filtered collection.\n     *\/\n    public function filter($predicate = null)\n    {\n        $this->typeCheck->filter(func_get_args());\n\n        if (null === $predicate) {\n            $predicate = function ($key, $value) {\n                return null !== $value;\n            };\n        }\n\n        $result = new static(null, $this->hashFunction);\n\n        foreach ($this->elements as $element) {\n            list($key, $value) = $element;\n            if (call_user_func($predicate, $key, $value)) {\n                $result->set($key, $value);\n            }\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Produce a new collection by applying a transformation to each element.\n     *\n     * The new elements produced by the transform need not be of the same type.\n     * It is not guaranteed that the concrete type of the resulting collection will match this collection.\n     *\n     * The transform must be a callable with the following signature:\n     *  function (mixed $key, mixed $value) { return array($new_key, $new_value); }\n     *\n     * @param callable $transform The transform to apply to each element.\n     *\n     * @return IterableInterface A new collection produced by applying $transform to each element in this collection.\n     *\/\n    public function map($transform)\n    {\n        $this->typeCheck->map(func_get_args());\n\n        $result = new static(null, $this->hashFunction);\n\n        foreach ($this->elements as $element) {\n            list($key, $value) = $element;\n            $element = call_user_func($transform, $key, $value);\n            list($key, $value) = $element;\n            $result->set($key, $value);\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Partitions this collection into two collections according to a predicate.\n     *\n     * It is not guaranteed that the concrete type of the partitioned collections will match this collection.\n     *\n     * The predicate must be a callable with the following signature:\n     *  function (mixed $key, mixed $value) { return $result; }\n     *\n     * @param callable $predicate A predicate function used to determine which partitioned collection to place the elements in.\n     *\n     * @return tuple<IterableInterface,IterableInterface> A 2-tuple containing the partitioned collections. The first collection contains the element for which the predicate returned true.\n     *\/\n    public function partition($predicate)\n    {\n        $this->typeCheck->partition(func_get_args());\n\n        $left = new static(null, $this->hashFunction);\n        $right = new static(null, $this->hashFunction);\n\n        foreach ($this->elements as $hash => $element) {\n            if (call_user_func_array($predicate, $element)) {\n                $left->elements[$hash] = $element;\n            } else {\n                $right->elements[$hash] = $element;\n            }\n        }\n\n        return array($left, $right);\n    }\n\n    \/**\n     * Invokes the given callback on every element in the collection.\n     *\n     * This method behaves the same as {@see IterableInterface::map()} except that the return value of the callback is not retained.\n     *\n     * The callback must be a callable with the following signature:\n     *  function (mixed $key, mixed $value) { ... }\n     *\n     * @param callable $callback The callback to invoke with each element.\n     *\/\n    public function each($callback)\n    {\n        $this->typeCheck->each(func_get_args());\n\n        foreach ($this->elements as $element) {\n            call_user_func_array($callback, $element);\n        }\n    }\n\n    \/**\n     * Returns true if the given predicate returns true for all elements.\n     *\n     * The loop is short-circuited, exiting after the first element for which the predicate returns false.\n     *\n     * The predicate must be a callable with the following signature:\n     *  function (mixed $key, mixed $value) { return $result; }\n     *\n     * @param callable $predicate\n     *\n     * @return boolean True if $predicate($element) returns true for all elements; otherwise, false.\n     *\/\n    public function all($predicate)\n    {\n        $this->typeCheck->all(func_get_args());\n\n        foreach ($this->elements as $element) {\n            if (!call_user_func_array($predicate, $element)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \/**\n     * Returns true if the given predicate returns true for any element.\n     *\n     * The loop is short-circuited, exiting after the first element for which the predicate returns false.\n     *\n     * The predicate must be a callable with the following signature:\n     *  function (mixed $key, mixed $value) { return $result; }\n     *\n     * @param callable $predicate\n     *\n     * @return boolean True if $predicate($element) returns true for any element; otherwise, false.\n     *\/\n    public function any($predicate)\n    {\n        $this->typeCheck->any(func_get_args());\n\n        foreach ($this->elements as $element) {\n            if (call_user_func_array($predicate, $element)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of MutableIterableInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Filter this collection in-place.\n     *\n     * The predicate must be a callable with the following signature:\n     *  function (mixed $key, mixed $value) { return $true_to_retain_element; }\n     *\n     * @param callable|null $predicate A predicate function used to determine which elements to retain, or null to retain all elements with non-null values.\n     *\/\n    public function filterInPlace($predicate = null)\n    {\n        $this->typeCheck->filterInPlace(func_get_args());\n\n        if (null === $predicate) {\n            $predicate = function ($key, $value) {\n                return null !== $value;\n            };\n        }\n\n        foreach ($this->elements as $hash => $element) {\n            list($key, $value) = $element;\n            if (!call_user_func($predicate, $key, $value)) {\n                unset($this->elements[$hash]);\n            }\n        }\n    }\n\n    \/**\n     * Replace each element in the collection with the result of a transformation on that element.\n     *\n     * The new elements produced by the transform must be the same type.\n     *\n     * The transform must be a callable with the following signature:\n     *  function (mixed $key, mixed $value) { return $new_value; }\n     *\n     * @param callable $transform The transform to apply to each element.\n     *\/\n    public function mapInPlace($transform)\n    {\n        $this->typeCheck->mapInPlace(func_get_args());\n\n        foreach ($this->elements as $hash => $element) {\n            list($key, $value) = $element;\n            $this->elements[$hash][1] = call_user_func($transform, $key, $value);\n        }\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of AssociativeInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Check if the collection contains an element with the given key.\n     *\n     * @param mixed $key The key to check.\n     *\n     * @return boolean True if the collection contains the given key; otherwise, false.\n     *\/\n    public function hasKey($key)\n    {\n        $this->typeCheck->hasKey(func_get_args());\n\n        return array_key_exists($this->generateHash($key), $this->elements);\n    }\n\n    \/**\n     * Fetch the value associated with the given key.\n     *\n     * @param mixed $key The key to fetch.\n     *\n     * @return mixed                         The associated value.\n     * @throws Exception\\UnknownKeyException if no such key exists.\n     *\/\n    public function get($key)\n    {\n        $this->typeCheck->get(func_get_args());\n\n        $value = null;\n        if ($this->tryGet($key, $value)) {\n            return $value;\n        }\n\n        throw new Exception\\UnknownKeyException($key);\n    }\n\n    \/**\n     * Fetch the value associated with the given key if it exists.\n     *\n     * @param mixed $key    The key to fetch.\n     * @param mixed &$value Assigned the value associated with $key if it exists.\n     *\n     * @return boolean True if $key exists and $value was populated; otherwise, false.\n     *\/\n    public function tryGet($key, &$value)\n    {\n        $this->typeCheck->tryGet(func_get_args());\n\n        $hash = $this->generateHash($key);\n\n        if (array_key_exists($hash, $this->elements)) {\n            $element = $this->elements[$hash];\n            list($key, $value) = $element;\n\n            return true;\n        }\n\n        return false;\n    }\n\n    \/**\n     * Fetch the value associated with the given key, or a default value if it does not exist.\n     *\n     * @param mixed $key     The key to fetch.\n     * @param mixed $default The default value to return if $key does not exist.\n     *\n     * @return mixed The value associated with $key, or the $default if nos such key exists.\n     *\/\n    public function getWithDefault($key, $default = null)\n    {\n        $this->typeCheck->getWithDefault(func_get_args());\n\n        $value = null;\n        if ($this->tryGet($key, $value)) {\n            return $value;\n        }\n\n        return $default;\n    }\n\n    \/**\n     * Return the value associated with the first key that exists.\n     *\n     * Takes a variable number of keys and searches for each one in order,\n     * returns the value associated with the first key that exists.\n     *\n     * @param mixed $key            The key to search for.\n     * @param mixed $additional,... Additional keys to search for.\n     *\n     * @return mixed                         The value associated with the first key that exists.\n     * @throws Exception\\UnknownKeyException if none of the keys exist.\n     *\/\n    public function cascade($key)\n    {\n        $this->typeCheck->cascade(func_get_args());\n\n        return $this->cascadeIterable(func_get_args());\n    }\n\n    \/**\n     * Return the value associated with the first key that exists, or a default value if none of the provided keys exist.\n     *\n     * @param mixed $default        The default value to return if no such keys exist.\n     * @param mixed $key            The key to search for.\n     * @param mixed $additional,... Additional keys to search for.\n     *\n     * @return mixed The value associated with the first key that exists, or $default if none of the keys exist.\n     *\/\n    public function cascadeWithDefault($default, $key)\n    {\n        $this->typeCheck->cascadeWithDefault(func_get_args());\n\n        $keys = func_get_args();\n        $default = array_shift($keys);\n\n        return $this->cascadeIterableWithDefault($default, $keys);\n    }\n\n    \/**\n     * Return the value associated with the first existing key in the given sequence.\n     *\n     * Behaves as per {@see Map::cascade()} except that the keys are provided as\n     * a traversable (eg, array) instead of via a variable argument list.\n     *\n     * @param mixed<mixed> $keys The list of keys.\n     *\n     * @return mixed                         The value associated with the first key that exists.\n     * @throws Exception\\UnknownKeyException if none of the keys exist.\n     *\/\n    public function cascadeIterable($keys)\n    {\n        $this->typeCheck->cascadeIterable(func_get_args());\n\n        $value = null;\n        foreach ($keys as $key) {\n            if ($this->tryGet($key, $value)) {\n                return $value;\n            }\n        }\n\n        throw new Exception\\UnknownKeyException($key);\n    }\n\n    \/**\n     * Return the value associated with the first existing key in the given sequence, or a default value if none of the provided keys exist.\n     *\n     * Behaves as per {@see Map::cascadeDefault()} except that the keys are provided as\n     * a traversable (eg, array) instead of via a variable argument list.\n     *\n     * @param mixed        $default The default value to return if no such keys exist.\n     * @param mixed<mixed> $keys    The list of keys.\n     *\n     * @return mixed The value associated with the first key that exists, or $default if none of the keys exist.\n     *\/\n    public function cascadeIterableWithDefault($default, $keys)\n    {\n        $this->typeCheck->cascadeIterableWithDefault(func_get_args());\n\n        $value = null;\n        foreach ($keys as $key) {\n            if ($this->tryGet($key, $value)) {\n                return $value;\n            }\n        }\n\n        return $default;\n    }\n\n    \/**\n     * Fetch a native array containing the keys in the collection.\n     *\n     * There is no guarantee that the order of keys will match the order of values produced by {@see Map::values()}.\n     *\n     * @return array A native array containing the keys in the collection.\n     *\/\n    public function keys()\n    {\n        $this->typeCheck->keys(func_get_args());\n\n        $keys = array();\n        foreach ($this->elements as $element) {\n            list($key, $value) = $element;\n            $keys[] = $key;\n        }\n\n        return $keys;\n    }\n\n    \/**\n     * Fetch a native array containing the values in the collection.\n     *\n     * There is no guarantee that the order of values will match the order of keys produced by {@see Map::keys()}.\n     *\n     * @return array A native array containing the values in the collection.\n     *\/\n    public function values()\n    {\n        $this->typeCheck->values(func_get_args());\n\n        $values = array();\n        foreach ($this->elements as $element) {\n            list($key, $value) = $element;\n            $values[] = $value;\n        }\n\n        return $values;\n    }\n\n    \/**\n     * Produce a new collection containing the elements of this collection and one or more other collections.\n     *\n     * Any existing keys are overwritten from left to right.\n     * It is not guaranteed that the concrete type of the merged collection will match this collection.\n     *\n     * @param AssociativeInterface $collection     The collection to combine.\n     * @param AssociativeInterface $additional,... Additional collections to combine.\n     *\n     * @return AssociativeInterface The merged collection.\n     *\/\n    public function merge(AssociativeInterface $collection)\n    {\n        $this->typeCheck->merge(func_get_args());\n\n        $result = clone $this;\n\n        foreach (func_get_args() as $collection) {\n            foreach ($collection->elements() as $element) {\n                list($key, $value) = $element;\n                $result->set($key, $value);\n            }\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Create a new collection containing the elements associated with the provided keys.\n     *\n     * It is not guaranteed that the concrete type of the projected collection will match this collection.\n     *\n     * @param mixed $key            The key to include in the new collection.\n     * @param mixed $additional,... \u00c5dditional keys to include in the new collection.\n     *\n     * @return AssociativeInterface The projection of the collection.\n     *\/\n    public function project($key)\n    {\n        $this->typeCheck->project(func_get_args());\n\n        return $this->projectIterable(func_get_args());\n    }\n\n    \/**\n     * Create a new collection containing the elements associated with the provided keys.\n     *\n     * It is not guaranteed that the concrete type of the projected collection will match this collection.\n     *\n     * @param mixed<mixed> $keys The keys to include in the new collection.\n     *\n     * @return AssociativeInterface The projection of the collection.\n     *\/\n    public function projectIterable($keys)\n    {\n        $this->typeCheck->projectIterable(func_get_args());\n\n        $result = new static(null, $this->hashFunction);\n\n        $value = null;\n        foreach ($keys as $key) {\n            if ($this->tryGet($key, $value)) {\n                $result->set($key, $value);\n            }\n        }\n\n        return $result;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of MutableAssociativeInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Associate a value with a key.\n     *\n     * Associates $value with $key regardless of whether or not $key already exists.\n     *\n     * @see Map::add()\n     * @see Map::replace()\n     *\n     * @param mixed $key   The element's key.\n     * @param mixed $value The element's value.\n     *\/\n    public function set($key, $value)\n    {\n        $this->typeCheck->set(func_get_args());\n\n        $hash = $this->generateHash($key);\n        $this->elements[$hash] = array($key, $value);\n    }\n\n    \/**\n     * Associate a value with a new key.\n     *\n     * Associates $value with $key only if $key does not already exist.\n     *\n     * @see Map::set()\n     * @see Map::replace()\n     * @see Map::tryAdd()\n     *\n     * @param mixed $key   The element's key.\n     * @param mixed $value The element's value.\n     *\n     * @throws Exception\\DuplicateKeyException if $key already exists.\n     *\/\n    public function add($key, $value)\n    {\n        $this->typeCheck->add(func_get_args());\n\n        if (!$this->tryAdd($key, $value)) {\n            throw new Exception\\DuplicateKeyException($key);\n        }\n    }\n\n    \/**\n     * Associate a value with a new key.\n     *\n     * Associates $value with $key only if $key does not already exist.\n     *\n     * @see Map::add()\n     *\n     * @param mixed $key   The element's key.\n     * @param mixed $value The element's value.\n     *\n     * @return boolean True if $key did not already exist and the value has been set; otherwise, false.\n     *\/\n    public function tryAdd($key, $value)\n    {\n        $this->typeCheck->tryAdd(func_get_args());\n\n        $hash = $this->generateHash($key);\n        if (array_key_exists($hash, $this->elements)) {\n            return false;\n        }\n\n        $this->elements[$hash] = array($key, $value);\n\n        return true;\n    }\n\n    \/**\n     * Associate a new value with an existing key.\n     *\n     * Associates $value with $key only if $key already exists.\n     *\n     * @see Map::add()\n     * @see Map::set()\n     * @see Map::tryReplace()\n     *\n     * @param mixed $key   The element's key.\n     * @param mixed $value The element's value.\n     *\n     * @return mixed                         The value previously associated with this key.\n     * @throws Exception\\UnknownKeyException if $key does not already exist.\n     *\/\n    public function replace($key, $value)\n    {\n        $this->typeCheck->replace(func_get_args());\n\n        $previous = null;\n        if (!$this->tryReplace($key, $value, $previous)) {\n            throw new Exception\\UnknownKeyException($key);\n        }\n\n        return $previous;\n    }\n\n    \/**\n     * Associate a new value with an existing key.\n     *\n     * Associates $value with $key only if $key already exists.\n     *\n     * @see Map::replace()\n     *\n     * @param mixed $key       The element's key.\n     * @param mixed $value     The element's value.\n     * @param mixed &$previous Assigned the value previously associated with $key.\n     *\n     * @return boolean True if $key already exists and the new value has been set; otherwise, false.\n     *\/\n    public function tryReplace($key, $value, &$previous = null)\n    {\n        $this->typeCheck->tryReplace(func_get_args());\n\n        $hash = $this->generateHash($key);\n        if (!array_key_exists($hash, $this->elements)) {\n            return false;\n        }\n\n        list(, $previous) = $this->elements[$hash];\n        $this->elements[$hash] = array($key, $value);\n\n        return true;\n    }\n\n    \/**\n     * Remove an element from the collection.\n     *\n     * @param mixed $key The key of the element to remove.\n     *\n     * @return mixed                         The value associated with this key.\n     * @throws Exception\\UnknownKeyException if $key does not exist.\n     *\/\n    public function remove($key)\n    {\n        $this->typeCheck->remove(func_get_args());\n\n        $value = null;\n        if (!$this->tryRemove($key, $value)) {\n            throw new Exception\\UnknownKeyException($key);\n        }\n\n        return $value;\n    }\n\n    \/**\n     * Remove an element from the collection.\n     *\n     * @param mixed $key    The key of the element to remove.\n     * @param mixed &$value Assigned the value associated with $key if it exists.\n     *\n     * @return boolean True if the key exists and has been removed; otherwise, false.\n     *\/\n    public function tryRemove($key, &$value = null)\n    {\n        $this->typeCheck->tryRemove(func_get_args());\n\n        $hash = $this->generateHash($key);\n        if (!array_key_exists($hash, $this->elements)) {\n            return false;\n        }\n\n        $element = $this->elements[$hash];\n        list($key, $value) = $element;\n        unset($this->elements[$hash]);\n\n        return true;\n    }\n\n    \/**\n     * Add the elements from one or more other collections to this collection.\n     *\n     * Any existing keys are overwritten from left to right.\n     *\n     * @param AssociativeInterface $collection     The collection to merge.\n     * @param AssociativeInterface $additional,... Additional collections to merge.\n     *\/\n    public function mergeInPlace(AssociativeInterface $collection)\n    {\n        $this->typeCheck->mergeInPlace(func_get_args());\n\n        foreach (func_get_args() as $collection) {\n            foreach ($collection->elements() as $element) {\n                list($key, $value) = $element;\n                $this->set($key, $value);\n            }\n        }\n    }\n\n    \/**\n     * Swap the elements associated with two keys.\n     *\n     * @param mixed $key1 The key of the first element.\n     * @param mixed $key2 The key of the second element.\n     *\n     * @throws Exception\\UnknownKeyException if $key1 or $key2 does not already exist.\n     *\/\n    public function swap($key1, $key2)\n    {\n        $this->typeCheck->swap(func_get_args());\n\n        $hash1 = $this->generateHash($key1);\n        $hash2 = $this->generateHash($key2);\n\n        if (!array_key_exists($hash1, $this->elements)) {\n            throw new Exception\\UnknownKeyException($key1);\n        } elseif (!array_key_exists($hash2, $this->elements)) {\n            throw new Exception\\UnknownKeyException($key2);\n        }\n\n        $temp = $this->elements[$hash1][1];\n        $this->elements[$hash1][1] = $this->elements[$hash2][1];\n        $this->elements[$hash2][1] = $temp;\n    }\n\n    \/**\n     * Swap the elements associated with two keys.\n     *\n     * @param mixed $key1 The key of the first element.\n     * @param mixed $key2 The key of the second element.\n     *\n     * @return boolean True if $key1 and $key2 exist and the swap is successful.\n     *\/\n    public function trySwap($key1, $key2)\n    {\n        $this->typeCheck->trySwap(func_get_args());\n\n        $hash1 = $this->generateHash($key1);\n        $hash2 = $this->generateHash($key2);\n\n        if (!array_key_exists($hash1, $this->elements)) {\n            return false;\n        } elseif (!array_key_exists($hash2, $this->elements)) {\n            return false;\n        }\n\n        $temp = $this->elements[$hash1][1];\n        $this->elements[$hash1][1] = $this->elements[$hash2][1];\n        $this->elements[$hash2][1] = $temp;\n\n        return true;\n    }\n\n    \/**\n     * Move an element from one key to another, replacing the target key if it already exists.\n     *\n     * @see Map::tryMove()\n     * @see Map::rename()\n     * @see Map::tryRename()\n     *\n     * @param mixed $source The existing key.\n     * @param mixed $target The new key.\n     *\n     * @throws Exception\\UnknownKeyException if $source does not already exist.\n     *\/\n    public function move($source, $target)\n    {\n        $this->typeCheck->move(func_get_args());\n\n        $value = $this->remove($source);\n        $this->set($target, $value);\n    }\n\n    \/**\n     * Move an element from one key to another, replacing the target key if it already exists.\n     *\n     * @see Map::move()\n     * @see Map::rename()\n     * @see Map::tryRename()\n     *\n     * @param mixed $source The existing key.\n     * @param mixed $target The new key.\n     *\n     * @return boolean True if $source exists and the move is successful.\n     *\/\n    public function tryMove($source, $target)\n    {\n        $this->typeCheck->tryMove(func_get_args());\n\n        $value = null;\n        if ($this->tryRemove($source, $value)) {\n            $this->set($target, $value);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    \/**\n     * Move an element from one key to another.\n     *\n     * It is an error if the target key already exists.\n     *\n     * @see Map::move()\n     * @see Map::tryMove()\n     * @see Map::tryRename()\n     *\n     * @param mixed $source The existing key.\n     * @param mixed $target The new key.\n     *\n     * @throws Exception\\UnknownKeyException   if $source does not already exist.\n     * @throws Exception\\DuplicateKeyException if $target already exists.\n     *\/\n    public function rename($source, $target)\n    {\n        $this->typeCheck->rename(func_get_args());\n\n        $hash1 = $this->generateHash($source);\n        $hash2 = $this->generateHash($target);\n\n        if (!array_key_exists($hash1, $this->elements)) {\n            throw new Exception\\UnknownKeyException($source);\n        } elseif (array_key_exists($hash2, $this->elements)) {\n            throw new Exception\\DuplicateKeyException($target);\n        }\n\n        $this->elements[$hash2] = array(\n            $target,\n            $this->elements[$hash1][1]\n        );\n\n        unset($this->elements[$hash1]);\n    }\n\n    \/**\n     * Move an element from one key to another.\n     *\n     * It is an error if the target key already exists.\n     *\n     * @see Map::move()\n     * @see Map::tryMove()\n     * @see Map::rename()\n     *\n     * @param mixed $source The existing key.\n     * @param mixed $target The new key.\n     *\n     * @return boolean True if $source exists, $target does not exist and the move is successful.\n     *\/\n    public function tryRename($source, $target)\n    {\n        $this->typeCheck->tryRename(func_get_args());\n\n        $hash1 = $this->generateHash($source);\n        $hash2 = $this->generateHash($target);\n\n        if (!array_key_exists($hash1, $this->elements)) {\n            return false;\n        } elseif (array_key_exists($hash2, $this->elements)) {\n            return false;\n        }\n\n        $this->elements[$hash2] = array(\n            $target,\n            $this->elements[$hash1][1]\n        );\n\n        unset($this->elements[$hash1]);\n\n        return true;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of Countable \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    public function count()\n    {\n        $this->typeCheck->count(func_get_args());\n\n        return $this->size();\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of Iterator \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    public function current()\n    {\n        $this->typeCheck->current(func_get_args());\n\n        $element = current($this->elements);\n        list($key, $value) = $element;\n\n        return $value;\n    }\n\n    public function key()\n    {\n        $this->typeCheck->key(func_get_args());\n\n        $element = current($this->elements);\n        list($key, $value) = $element;\n\n        return $key;\n    }\n\n    public function next()\n    {\n        $this->typeCheck->next(func_get_args());\n\n        next($this->elements);\n    }\n\n    public function rewind()\n    {\n        $this->typeCheck->rewind(func_get_args());\n\n        reset($this->elements);\n    }\n\n    public function valid()\n    {\n        $this->typeCheck->valid(func_get_args());\n\n        return null !== key($this->elements);\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of ArrayAccess \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Check if the collection contains an element with the given key.\n     *\n     * @param mixed $offset The key to check.\n     *\n     * @return boolean True if the collection contains the given key; otherwise, false.\n     *\/\n    public function offsetExists($offset)\n    {\n        $this->typeCheck->offsetExists(func_get_args());\n\n        return $this->hasKey($offset);\n    }\n\n    \/**\n     * Fetch the value associated with the given key.\n     *\n     * @param mixed $offset The key to fetch.\n     *\n     * @return mixed                         The associated value.\n     * @throws Exception\\UnknownKeyException if no such key exists.\n     *\/\n    public function offsetGet($offset)\n    {\n        $this->typeCheck->offsetGet(func_get_args());\n\n        return $this->get($offset);\n    }\n\n    \/**\n     * Associate a value with a key.\n     *\n     * Associates $value with $offset regardless of whether or not $key already exists.\n     *\n     * @param mixed $offset The element's key.\n     * @param mixed $value  The element's value.\n     *\/\n    public function offsetSet($offset, $value)\n    {\n        $this->typeCheck->offsetSet(func_get_args());\n\n        $this->set($offset, $value);\n    }\n\n    \/**\n     * Remove an element from the collection, if it is present.\n     *\n     * @param mixed $offset The key of the element to remove.\n     *\/\n    public function offsetUnset($offset)\n    {\n        $this->typeCheck->offsetUnset(func_get_args());\n\n        $this->tryRemove($offset);\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of Serializable \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Serialize the collection.\n     *\n     * @return string The serialized data.\n     *\/\n    public function serialize()\n    {\n        $this->typeCheck->serialize(func_get_args());\n\n        return serialize(\n            array(\n                $this->elements(),\n                $this->hashFunction\n            )\n        );\n    }\n\n    \/**\n     * Unserialize collection data.\n     *\n     * @param string $packet The serialized data.\n     *\/\n    public function unserialize($packet)\n    {\n        TypeCheck::get(__CLASS__)->unserialize(func_get_args());\n\n        list($elements, $hashFunction) = unserialize($packet);\n\n        $this->__construct(null, $hashFunction);\n\n        foreach ($elements as $element) {\n            list($key, $value) = $element;\n            $this->set($key, $value);\n        }\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Model specific methods \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * @param mixed $key\n     *\n     * @return integer|string\n     *\/\n    private function generateHash($key)\n    {\n        return call_user_func($this->hashFunction, $key);\n    }\n\n    private $typeCheck;\n    private $hashFunction;\n    private $elements;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,73,null,73,73,73,null,73,73,null,73,1,1,1,1,73,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,null,4,null,null,null,null,null,null,null,null,null,4,null,4,null,null,null,null,null,null,null,null,null,null,null,null,1,1,null,null,1,1,1,1,1,null,null,1,null,1,1,null,1,1,1,1,null,null,1,1,1,1,1,null,null,null,null,null,null,null,null,null,null,null,4,null,4,4,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,28,null,28,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,1,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,1,1,1,1,null,2,null,2,2,2,2,2,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,1,1,1,1,1,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,null,1,1,1,1,1,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,1,1,1,1,null,2,2,2,2,2,2,2,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,1,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,6,null,6,null,null,null,null,null,null,null,null,null,null,null,null,9,null,9,9,7,null,null,2,null,null,null,null,null,null,null,null,null,null,null,null,18,null,18,null,18,15,15,null,15,null,null,11,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,3,3,3,2,null,3,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,2,2,2,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,1,1,null,1,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,1,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,1,1,1,1,1,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,2,2,2,2,2,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,60,null,60,60,60,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,3,3,2,null,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,2,1,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,null,4,4,2,null,null,2,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,5,null,5,5,2,null,null,3,null,null,null,null,null,null,null,null,null,null,null,null,9,null,9,9,5,null,null,5,5,5,null,5,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,1,1,1,1,null,null,null,null,null,null,null,null,null,null,null,3,null,3,3,null,3,1,2,1,null,null,1,1,1,1,null,null,null,null,null,null,null,null,null,null,null,3,null,3,3,null,3,1,2,1,null,null,1,1,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,1,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,2,1,null,1,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,3,3,null,3,1,2,1,null,null,1,1,1,1,null,1,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,3,3,null,3,1,2,1,null,null,1,1,1,1,null,1,null,1,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,2,null,2,2,null,2,null,null,null,null,2,null,2,2,null,2,null,null,null,null,2,null,2,2,null,null,null,2,null,2,2,null,null,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,null,null,null,null,null,null,null,null,1,null,1,1,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,2,2,2,2,null,null,null,null,null,null,null,null,null,2,null,2,null,2,null,2,1,1,2,2,null,null,null,null,null,null,null,null,null,null,null,null,70,null,null,null,null,null,null]},{"name":"Icecave\/Collections\/MutableAssociativeInterface.php","source":"<?php\nnamespace Icecave\\Collections;\n\n\/**\n * An associative collection is a variable-sized collection that supports efficient retrieval of values based on keys.\n *\n * Each element in a associative collection is a 2-tuple of key and value.\n *\n * Mutable associative collections support insertion and removal of elements, but differ from sequences in that they do\n * not provide a mechanism for inserting an element at a specific position.\n *\/\ninterface MutableAssociativeInterface extends AssociativeInterface, MutableIterableInterface\n{\n    \/**\n     * Associate a value with a key.\n     *\n     * Associates $value with $key regardless of whether or not $key already exists.\n     *\n     * @see MutableAssociativeInterface::add()\n     * @see MutableAssociativeInterface::replace()\n     *\n     * @param mixed $key   The element's key.\n     * @param mixed $value The element's value.\n     *\/\n    public function set($key, $value);\n\n    \/**\n     * Associate a value with a new key.\n     *\n     * Associates $value with $key only if $key does not already exist.\n     *\n     * @see MutableAssociativeInterface::set()\n     * @see MutableAssociativeInterface::replace()\n     * @see MutableAssociativeInterface::tryAdd()\n     *\n     * @param mixed $key   The element's key.\n     * @param mixed $value The element's value.\n     *\n     * @throws Exception\\DuplicateKeyException if $key already exists.\n     *\/\n    public function add($key, $value);\n\n    \/**\n     * Associate a value with a new key.\n     *\n     * Associates $value with $key only if $key does not already exist.\n     *\n     * @see MutableAssociativeInterface::add()\n     *\n     * @param mixed $key   The element's key.\n     * @param mixed $value The element's value.\n     *\n     * @return boolean True if $key did not already exist and the value has been set; otherwise, false.\n     *\/\n    public function tryAdd($key, $value);\n\n    \/**\n     * Associate a new value with an existing key.\n     *\n     * Associates $value with $key only if $key already exists.\n     *\n     * @see MutableAssociativeInterface::add()\n     * @see MutableAssociativeInterface::set()\n     * @see MutableAssociativeInterface::tryReplace()\n     *\n     * @param mixed $key   The element's key.\n     * @param mixed $value The element's value.\n     *\n     * @return mixed                         The value previously associated with this key.\n     * @throws Exception\\UnknownKeyException if $key does not already exist.\n     *\/\n    public function replace($key, $value);\n\n    \/**\n     * Associate a new value with an existing key.\n     *\n     * Associates $value with $key only if $key already exists.\n     *\n     * @see MutableAssociativeInterface::replace()\n     *\n     * @param mixed $key       The element's key.\n     * @param mixed $value     The element's value.\n     * @param mixed &$previous Assigned the value previously associated with $key.\n     *\n     * @return boolean True if $key already exists and the new value has been set; otherwise, false.\n     *\/\n    public function tryReplace($key, $value, &$previous = null);\n\n    \/**\n     * Remove an element from the collection.\n     *\n     * @param mixed $key The key of the element to remove.\n     *\n     * @return mixed                         The value associated with this key.\n     * @throws Exception\\UnknownKeyException if $key does not exist.\n     *\/\n    public function remove($key);\n\n    \/**\n     * Remove an element from the collection.\n     *\n     * @param mixed $key    The key of the element to remove.\n     * @param mixed &$value Assigned the value associated with $key if it exists.\n     *\n     * @return boolean True if the key exists and has been removed; otherwise, false.\n     *\/\n    public function tryRemove($key, &$value = null);\n\n    \/**\n     * Add the elements from one or more other collections to this collection.\n     *\n     * Any existing keys are overwritten from left to right.\n     *\n     * @param AssociativeInterface $collection     The collection to merge.\n     * @param AssociativeInterface $additional,... Additional collections to merge.\n     *\/\n    public function mergeInPlace(AssociativeInterface $collection);\n\n    \/**\n     * Swap the elements associated with two keys.\n     *\n     * @param mixed $key1 The key of the first element.\n     * @param mixed $key2 The key of the second element.\n     *\n     * @throws Exception\\UnknownKeyException if $key1 or $key2 does not already exist.\n     *\/\n    public function swap($key1, $key2);\n\n    \/**\n     * Swap the elements associated with two keys.\n     *\n     * @param mixed $key1 The key of the first element.\n     * @param mixed $key2 The key of the second element.\n     *\n     * @return boolean True if $key1 and $key2 exist and the swap is successful.\n     *\/\n    public function trySwap($key1, $key2);\n\n    \/**\n     * Move an element from one key to another, replacing the target key if it already exists.\n     *\n     * @see MutableAssociativeInterface::tryMove()\n     * @see MutableAssociativeInterface::rename()\n     * @see MutableAssociativeInterface::tryRename()\n     *\n     * @param mixed $source The existing key.\n     * @param mixed $target The new key.\n     *\n     * @throws Exception\\UnknownKeyException if $source does not already exist.\n     *\/\n    public function move($source, $target);\n\n    \/**\n     * Move an element from one key to another, replacing the target key if it already exists.\n     *\n     * @see MutableAssociativeInterface::move()\n     * @see MutableAssociativeInterface::rename()\n     * @see MutableAssociativeInterface::tryRename()\n     *\n     * @param mixed $source The existing key.\n     * @param mixed $target The new key.\n     *\n     * @return boolean True if $source exists and the move is successful.\n     *\/\n    public function tryMove($source, $target);\n\n    \/**\n     * Move an element from one key to another.\n     *\n     * It is an error if the target key already exists.\n     *\n     * @see MutableAssociativeInterface::move()\n     * @see MutableAssociativeInterface::tryMove()\n     * @see MutableAssociativeInterface::tryRename()\n     *\n     * @param mixed $source The existing key.\n     * @param mixed $target The new key.\n     *\n     * @throws Exception\\UnknownKeyException   if $source does not already exist.\n     * @throws Exception\\DuplicateKeyException if $target already exists.\n     *\/\n    public function rename($source, $target);\n\n    \/**\n     * Move an element from one key to another.\n     *\n     * It is an error if the target key already exists.\n     *\n     * @see MutableAssociativeInterface::move()\n     * @see MutableAssociativeInterface::tryMove()\n     * @see MutableAssociativeInterface::rename()\n     *\n     * @param mixed $source The existing key.\n     * @param mixed $target The new key.\n     *\n     * @return boolean True if $source exists, $target does not exist and the move is successful.\n     *\/\n    public function tryRename($source, $target);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Collections\/MutableCollectionInterface.php","source":"<?php\nnamespace Icecave\\Collections;\n\n\/**\n * A mutable collection is a collection on which elements can be added and removed.\n *\/\ninterface MutableCollectionInterface extends CollectionInterface\n{\n    \/**\n     * Remove all elements from the collection.\n     *\/\n    public function clear();\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Collections\/MutableIterableInterface.php","source":"<?php\nnamespace Icecave\\Collections;\n\n\/**\n * A mutable collection is a collection on which elements can be added and removed.\n *\/\ninterface MutableIterableInterface extends IterableInterface, MutableCollectionInterface\n{\n    \/**\n     * Filter this collection in-place.\n     *\n     * @param callable|null $predicate A predicate function used to determine which elements to retain, or null to retain all non-null elements.\n     *\/\n    public function filterInPlace($predicate = null);\n\n    \/**\n     * Replace each element in the collection with the result of a transformation on that element.\n     *\n     * The new elements produced by the transform must be the same type.\n     *\n     * @param callable $transform The transform to apply to each element.\n     *\/\n    public function mapInPlace($transform);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Collections\/MutableRandomAccessInterface.php","source":"<?php\nnamespace Icecave\\Collections;\n\n\/**\n * A mutable random access sequence is a sequence that allows for insertion and removal of elements by their position in the sequence.\n *\/\ninterface MutableRandomAccessInterface extends RandomAccessInterface, MutableSequenceInterface\n{\n    \/**\n     * Replace the element at a particular position in the sequence.\n     *\n     * @param integer $index   The index of the element to set, if index is a negative number the element that far from the end of the sequence is set.\n     * @param mixed   $element The element to set.\n     *\n     * @throws Exception\\IndexException if $index is out of range.\n     *\/\n    public function set($index, $element);\n\n    \/**\n     * Insert an element at a particular index.\n     *\n     * @param integer $index   The index at which the element is inserted, if index is a negative number the element is inserted that far from the end of the sequence.\n     * @param mixed   $element The element to insert.\n     *\n     * @throws Exception\\IndexException if $index is out of range.\n     *\/\n    public function insert($index, $element);\n\n    \/**\n     * Insert a range of elements at a particular index.\n     *\n     * @param integer      $index    The index at which the elements are inserted, if index is a negative number the elements are inserted that far from the end of the sequence.\n     * @param mixed<mixed> $elements The elements to insert.\n     *\/\n    public function insertMany($index, $elements);\n\n    \/**\n     * Remove the element at a given index.\n     *\n     * Elements after the given endex are moved forward by one.\n     *\n     * @param integer $index The index of the element to remove, if index is a negative number the element that far from the end of the sequence is removed.\n     *\n     * @throws Exception\\IndexException if $index is out of range.\n     *\/\n    public function remove($index);\n\n    \/**\n     * Remove a range of elements at a given index.\n     *\n     * @param integer      $index The index of the first element to remove, if index is a negative number the removal begins that far from the end of the sequence.\n     * @param integer|null $count The number of elements to remove, or null to remove all elements up to the end of the sequence.\n     *\n     * @throws Exception\\IndexException if $index is out of range.\n     *\/\n    public function removeMany($index, $count = null);\n\n    \/**\n     * Remove a range of elements between two indices.\n     *\n     * Removes all elements in the range [$begin, $end), i.e. $begin is inclusive, $end is exclusive.\n     *\n     * @param integer $begin The index of the first element to remove, if begin is a negative number the removal begins that far from the end of the sequence.\n     * @param integer $end   The index of the last element to remove, if end is a negative number the removal ends that far from the end of the sequence.\n     *\n     * @throws Exception\\IndexException if $begin or $end is out of range.\n     *\/\n    public function removeRange($begin, $end);\n\n    \/**\n     * Replace a range of elements with a second set of elements.\n     *\n     * @param integer      $index    The index of the first element to replace, if index is a negative number the replace begins that far from the end of the sequence.\n     * @param mixed<mixed> $elements The elements to insert.\n     * @param integer|null $count    The number of elements to replace, or null to replace all elements up to the end of the sequence.\n     *\/\n    public function replace($index, $elements, $count = null);\n\n    \/**\n     * Replace a range of elements with a second set of elements.\n     *\n     * Replaces all elements in the range [$begin, $end), i.e. $begin is inclusive, $end is exclusive.\n     *\n     * @param integer      $begin    The index of the first element to replace, if begin is a negative number the replace begins that far from the end of the sequence.\n     * @param integer      $end      The index of the last element to replace, if end is a negativ enumber the replace ends that far from the end of the sequence.\n     * @param mixed<mixed> $elements The elements to insert.\n     *\/\n    public function replaceRange($begin, $end, $elements);\n\n    \/**\n     * Swap the elements at two index positions.\n     *\n     * @param integer $index1 The index of the first element.\n     * @param integer $index2 The index of the second element.\n     *\n     * @throws Exception\\IndexException if $index1 or $index2 is out of range.\n     *\/\n    public function swap($index1, $index2);\n\n    \/**\n     * Swap the elements at two index positions.\n     *\n     * @param integer $index1 The index of the first element.\n     * @param integer $index2 The index of the second element.\n     *\n     * @return boolean True if $index1 and $index2 are in range and the swap is successful.\n     *\/\n    public function trySwap($index1, $index2);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Collections\/MutableSequenceInterface.php","source":"<?php\nnamespace Icecave\\Collections;\n\n\/**\n * A Sequence is a variable-sized collection whose elements are arranged in a strict linear order.\n *\n * Mutable sequences support insertion and removal of elements.\n *\/\ninterface MutableSequenceInterface extends SequenceInterface, MutableIterableInterface\n{\n    \/**\n     * Sort this sequence in-place.\n     *\n     * @param callable|null $comparator A strcmp style comparator function.\n     *\/\n    public function sortInPlace($comparator = null);\n\n    \/**\n     * Reverse this sequence in-place.\n     *\/\n    public function reverseInPlace();\n\n    \/**\n     * Appending elements in the given sequence to this sequence.\n     *\n     * @param mixed<mixed> $sequence       The sequence to append.\n     * @param mixed<mixed> $additional,... Additional sequences to append.\n     *\/\n    public function append($sequence);\n\n    \/**\n     * Add a new element to the front of the sequence.\n     *\n     * @param mixed $element The element to prepend.\n     *\/\n    public function pushFront($element);\n\n    \/**\n     * Remove and return the element at the front of the sequence.\n     *\n     * @return mixed                              The element at the front of the sequence.\n     * @throws Exception\\EmptyCollectionException if the collection is empty.\n     *\/\n    public function popFront();\n\n    \/**\n     * Remove the element at the front of the sequence.\n     *\n     * @param mixed &$element Assigned the removed element.\n     *\n     * @return boolean True if the front element is removed and assigned to $element; otherwise, false.\n     *\/\n    public function tryPopFront(&$element = null);\n\n    \/**\n     * Add a new element to the back of the sequence.\n     *\n     * @param mixed $element The element to append.\n     *\/\n    public function pushBack($element);\n\n    \/**\n     * Remove and return the element at the back of the sequence.\n     *\n     * @return mixed                              The element at the back of the sequence.\n     * @throws Exception\\EmptyCollectionException if the collection is empty.\n     *\/\n    public function popBack();\n\n    \/**\n     * Remove the element at the back of the sequence.\n     *\n     * @param mixed &$element Assigned the removed element.\n     *\n     * @return boolean True if the back element is removed and assigned to $element; otherwise, false.\n     *\/\n    public function tryPopBack(&$element = null);\n\n    \/**\n     * Resize the sequence.\n     *\n     * @param integer $size    The new size of the collection.\n     * @param mixed   $element The value to use for populating new elements when $size > $this->size().\n     *\/\n    public function resize($size, $element = null);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Collections\/PriorityQueue.php","source":"<?php\nnamespace Icecave\\Collections;\n\nuse Icecave\\Collections\\TypeCheck\\TypeCheck;\nuse Icecave\\Repr\\Repr;\nuse Serializable;\nuse SplPriorityQueue;\n\n\/**\n * A prioritized first-in\/first-out (FIFO) queue of elements.\n *\n * Higher priority values are moved closer to the front of the queue.\n *\n * Prioritization is provided by the prioritzation function specified in the constructor, but may\n * be optionally overridden by the second parameter to {@see PriorityQueue::push()}.\n *\/\nclass PriorityQueue extends Queue implements Serializable\n{\n    \/**\n     * @param callable          $prioritizer A function used to generate the priority for a given element.\n     * @param mixed<mixed>|null $collection  An iterable type containing the elements to include in this list, or null to create an empty list.\n     *\/\n    public function __construct($prioritizer, $collection = null)\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n\n        $this->prioritizer = $prioritizer;\n        parent::__construct($collection);\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of CollectionInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Fetch a string representation of the collection.\n     *\n     * The string may not describe all elements of the collection, but should at least\n     * provide information on the type and state of the collection.\n     *\n     * @return string A string representation of the collection.\n     *\/\n    public function __toString()\n    {\n        if ($this->isEmpty()) {\n            return '<PriorityQueue 0>';\n        }\n\n        return sprintf(\n            '<PriorityQueue %d [next: %s]>',\n            $this->size(),\n            Repr::repr($this->next())\n        );\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of MutableCollectionInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Remove all elements from the collection.\n     *\/\n    public function clear()\n    {\n        $this->typeCheck->clear(func_get_args());\n\n        $this->elements = new SplPriorityQueue;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of QueuedAccessInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Fetch the element at the front of the queue.\n     *\n     * @return mixed                              The element at the front of the queue.\n     * @throws Exception\\EmptyCollectionException if the collection is empty.\n     *\/\n    public function next()\n    {\n        $this->typeCheck->next(func_get_args());\n\n        if ($this->isEmpty()) {\n            throw new Exception\\EmptyCollectionException;\n        }\n\n        return $this->elements->top();\n    }\n\n    \/**\n     * Add a new element to the end of the queue.\n     *\n     * @param mixed        $element  The element to add.\n     * @param integer|null $priority The priority of the element being added, or NULL to use the queue's prioritizer.\n     *\/\n    public function push($element, $priority = null)\n    {\n        $this->typeCheck->push(func_get_args());\n\n        if (null == $priority) {\n            $priority = call_user_func($this->prioritizer, $element);\n        }\n\n        $this->elements->insert($element, $priority);\n    }\n\n    \/**\n     * Remove and return the element at the front of the queue.\n     *\n     * @return mixed                              The element at the front of the sequence.\n     * @throws Exception\\EmptyCollectionException if the collection is empty.\n     *\/\n    public function pop()\n    {\n        $this->typeCheck->pop(func_get_args());\n\n        if ($this->isEmpty()) {\n            throw new Exception\\EmptyCollectionException;\n        }\n\n        return $this->elements->extract();\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of Serializable \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Serialize the collection.\n     *\n     * @return string The serialized data.\n     *\/\n    public function serialize()\n    {\n        $this->typeCheck->serialize(func_get_args());\n\n        return serialize(\n            array(\n                $this->prioritizer,\n                iterator_to_array($this->elements)\n            )\n        );\n    }\n\n    \/**\n     * Unserialize collection data.\n     *\n     * @param string $packet The serialized data.\n     *\/\n    public function unserialize($packet)\n    {\n        TypeCheck::get(__CLASS__)->unserialize(func_get_args());\n\n        list($prioritizer, $elements) = unserialize($packet);\n        $this->__construct($prioritizer, $elements);\n    }\n\n    private $typeCheck;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,17,null,17,17,17,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,null,null,1,1,1,1,1,null,null,null,null,null,null,null,null,null,null,null,17,null,17,17,null,null,null,null,null,null,null,null,null,null,null,null,null,6,null,6,1,null,null,5,null,null,null,null,null,null,null,null,null,null,12,null,12,12,12,null,12,12,null,null,null,null,null,null,null,null,null,4,null,4,1,null,null,3,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,1,1,1,1,null,null,null,null,null,null,null,null,null,1,null,1,1,1,null,null,null]},{"name":"Icecave\/Collections\/Queue.php","source":"<?php\nnamespace Icecave\\Collections;\n\nuse Countable;\nuse Icecave\\Collections\\TypeCheck\\TypeCheck;\nuse Icecave\\Repr\\Repr;\nuse Serializable;\nuse SplQueue;\n\n\/**\n * A first-in\/first-out (FIFO) queue of elements.\n *\/\nclass Queue implements QueuedAccessInterface, Countable, Serializable\n{\n    \/**\n     * @param mixed<mixed>|null $collection An iterable type containing the elements to include in this list, or null to create an empty list.\n     *\/\n    public function __construct($collection = null)\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n\n        $this->clear();\n\n        if (null !== $collection) {\n            foreach ($collection as $element) {\n                $this->push($element);\n            }\n        }\n    }\n\n    public function __clone()\n    {\n        $this->typeCheck->validateClone(func_get_args());\n\n        $this->elements = clone $this->elements;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of CollectionInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Fetch the number of elements in the collection.\n     *\n     * @see CollectionInterface::isEmpty()\n     *\n     * @return integer The number of elements in the collection.\n     *\/\n    public function size()\n    {\n        $this->typeCheck->size(func_get_args());\n\n        return $this->elements->count();\n    }\n\n    \/**\n     * Check if the collection is empty.\n     *\n     * @return boolean True if the collection is empty; otherwise, false.\n     *\/\n    public function isEmpty()\n    {\n        $this->typeCheck->isEmpty(func_get_args());\n\n        return $this->elements->isEmpty();\n    }\n\n    \/**\n     * Fetch a string representation of the collection.\n     *\n     * The string may not describe all elements of the collection, but should at least\n     * provide information on the type and state of the collection.\n     *\n     * @return string A string representation of the collection.\n     *\/\n    public function __toString()\n    {\n        if ($this->isEmpty()) {\n            return '<Queue 0>';\n        }\n\n        return sprintf(\n            '<Queue %d [next: %s]>',\n            $this->size(),\n            Repr::repr($this->next())\n        );\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of MutableCollectionInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Remove all elements from the collection.\n     *\/\n    public function clear()\n    {\n        $this->typeCheck->clear(func_get_args());\n\n        $this->elements = new SplQueue;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of QueuedAccessInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Fetch the element at the front of the queue.\n     *\n     * @return mixed                              The element at the front of the queue.\n     * @throws Exception\\EmptyCollectionException if the collection is empty.\n     *\/\n    public function next()\n    {\n        $this->typeCheck->next(func_get_args());\n\n        if ($this->isEmpty()) {\n            throw new Exception\\EmptyCollectionException;\n        }\n\n        return $this->elements->bottom();\n    }\n\n    \/**\n     * Fetch the element at the front of the queue.\n     *\n     * @param mixed &$element Assigned the element at the front of the queue.\n     *\n     * @return boolean True is the element exists and was assigned to $element; otherwise, false.\n     *\/\n    public function tryNext(&$element)\n    {\n        $this->typeCheck->tryNext(func_get_args());\n\n        if ($this->isEmpty()) {\n            return false;\n        }\n\n        $element = $this->next();\n\n        return true;\n    }\n\n    \/**\n     * Add a new element to the end of the queue.\n     *\n     * @param mixed $element The element to add.\n     *\/\n    public function push($element)\n    {\n        $this->typeCheck->push(func_get_args());\n\n        $this->elements->push($element);\n    }\n\n    \/**\n     * Remove and return the element at the front of the queue.\n     *\n     * @return mixed                              The element at the front of the sequence.\n     * @throws Exception\\EmptyCollectionException if the collection is empty.\n     *\/\n    public function pop()\n    {\n        $this->typeCheck->pop(func_get_args());\n\n        if ($this->isEmpty()) {\n            throw new Exception\\EmptyCollectionException;\n        }\n\n        return $this->elements->dequeue();\n    }\n\n    \/**\n     * Remove the element at the front of the queue.\n     *\n     * @param mixed &$element Assigned the removed element.\n     *\n     * @return boolean True if the front element is removed and assigned to $element; otherwise, false.\n     *\/\n    public function tryPop(&$element = null)\n    {\n        $this->typeCheck->tryPop(func_get_args());\n\n        if ($this->isEmpty()) {\n            return false;\n        }\n\n        $element = $this->pop();\n\n        return true;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of Countable \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    public function count()\n    {\n        $this->typeCheck->count(func_get_args());\n\n        return $this->size();\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of Serializable \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Serialize the collection.\n     *\n     * @return string The serialized data.\n     *\/\n    public function serialize()\n    {\n        $this->typeCheck->serialize(func_get_args());\n\n        return serialize(iterator_to_array($this->elements));\n    }\n\n    \/**\n     * Unserialize collection data.\n     *\n     * @param string $packet The serialized data.\n     *\/\n    public function unserialize($packet)\n    {\n        TypeCheck::get(__CLASS__)->unserialize(func_get_args());\n\n        $elements = unserialize($packet);\n        $this->__construct($elements);\n    }\n\n    private $typeCheck;\n    protected $elements;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,17,null,17,null,17,2,2,2,2,17,null,null,null,1,null,1,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,7,null,7,null,null,null,null,null,null,null,null,null,14,null,14,null,null,null,null,null,null,null,null,null,null,null,null,1,1,null,null,1,1,1,1,1,null,null,null,null,null,null,null,null,null,null,null,17,null,17,17,null,null,null,null,null,null,null,null,null,null,null,null,null,5,null,5,1,null,null,4,null,null,null,null,null,null,null,null,null,null,null,2,null,2,1,null,null,1,null,1,null,null,null,null,null,null,null,null,null,12,null,12,12,null,null,null,null,null,null,null,null,null,6,null,6,1,null,null,5,null,null,null,null,null,null,null,null,null,null,null,2,null,2,1,null,null,1,null,1,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,1,null,1,1,1,null,null,null,null]},{"name":"Icecave\/Collections\/QueuedAccessInterface.php","source":"<?php\nnamespace Icecave\\Collections;\n\n\/**\n * The common interface between queues and stacks.\n *\/\ninterface QueuedAccessInterface extends MutableCollectionInterface\n{\n    \/**\n     * Fetch the element next to be returned by pop(), without removing it from the collection.\n     *\n     * @return mixed                              The next element.\n     * @throws Exception\\EmptyCollectionException if the collection is empty.\n     *\/\n    public function next();\n\n    \/**\n    * Fetch the element next to be returned by pop(), without removing it from the collection.\n     *\n     * @param mixed &$element Assigned the next element.\n     *\n     * @return boolean True is the element exists and was assigned to $element; otherwise, false.\n     *\/\n    public function tryNext(&$element);\n\n    \/**\n     * Add a new element.\n     *\n     * @param mixed $element The element to add.\n     *\/\n    public function push($element);\n\n    \/**\n     * Remove and return the next element.\n     *\n     * @return mixed                              The next element.\n     * @throws Exception\\EmptyCollectionException if the collection is empty.\n     *\/\n    public function pop();\n\n    \/**\n    * Remove the next element.\n     *\n     * @param mixed &$element Assigned the removed element.\n     *\n     * @return boolean True if the next element is removed and assigned to $element; otherwise, false.\n     *\/\n    public function tryPop(&$element = null);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Collections\/RandomAccessInterface.php","source":"<?php\nnamespace Icecave\\Collections;\n\n\/**\n * A random access sequence is a sequence that provides access to elements by their position in the sequence.\n *\/\ninterface RandomAccessInterface extends SequenceInterface\n{\n    \/**\n     * Fetch the element at the given index.\n     *\n     * @param mixed $index The index of the element to fetch, if index is a negative number the element that far from the end of the sequence is returned.\n     *\n     * @return mixed                    The element at $index.\n     * @throws Exception\\IndexException if $index is out of range.\n     *\/\n    public function get($index);\n\n    \/**\n     * Extract a range of elements.\n     *\n     * It is not guaranteed that the concrete type of the slice collection will match this collection.\n     *\n     * @param integer      $index The index from which the slice will start. If index is a negative number the slice will begin that far from the end of the sequence.\n     * @param integer|null $count The maximum number of elements to include in the slice, or null to include all elements from $index to the end of the sequence.\n     *\n     * @return SequenceInterface        The sliced sequence.\n     * @throws Exception\\IndexException if $index is out of range.\n     *\/\n    public function slice($index, $count = null);\n\n    \/**\n     * Extract a range of elements.\n     *\n     * It is not guaranteed that the concrete type of the slice collection will match this collection.\n     *\n     * Extracts all elements in the range [$begin, $end), i.e. $begin is inclusive, $end is exclusive.\n     *\n     * @param integer $begin The index from which the slice will start. If begin is a negative number the slice will begin that far from the end of the sequence.\n     * @param integer $end   The index at which the slice will end. If end is a negative number the slice will end that far from the end of the sequence.\n     *\n     * @return SequenceInterface        The sliced sequence.\n     * @throws Exception\\IndexException if $begin or $end is out of range.\n     *\/\n    public function range($begin, $end);\n\n    \/**\n     * Find the index of the first instance of a particular element in the sequence.\n     *\n     * @param mixed   $element    The element to search for.\n     * @param integer $startIndex The index to start searching from.\n     *\n     * @return integer|null             The index of the element, or null if is not present in the sequence.\n     * @throws Exception\\IndexException if $startIndex is out of range.\n     *\/\n    public function indexOf($element, $startIndex = 0);\n\n    \/**\n     * Find the index of the last instance of a particular element in the sequence.\n     *\n     * @param mixed        $element    The element to search for.\n     * @param integer|null $startIndex The index to start searching from, or null to use the last index.\n     *\n     * @return integer|null             The index of the element, or null if is not present in the sequence.\n     * @throws Exception\\IndexException if $startIndex is out of range.\n     *\/\n    public function indexOfLast($element, $startIndex = null);\n\n    \/**\n     * Find the index of the first instance of an element matching given criteria.\n     *\n     * @param callable $predicate  A predicate function used to determine which element constitutes a match.\n     * @param integer  $startIndex The index to start searching from.\n     *\n     * @return integer|null             The index of the element, or null if is not present in the sequence.\n     * @throws Exception\\IndexException if $startIndex is out of range.\n     *\/\n    public function find($predicate, $startIndex = 0);\n\n    \/**\n     * Find the index of the last instance of an element matching given criteria.\n     *\n     * @param callable     $predicate  A predicate function used to determine which element constitutes a match.\n     * @param integer|null $startIndex The index to start searching from, or null to use the last index.\n     *\n     * @return integer|null             The index of the element, or null if is not present in the sequence.\n     * @throws Exception\\IndexException if $startIndex is out of range.\n     *\/\n    public function findLast($predicate, $startIndex = null);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Collections\/SequenceInterface.php","source":"<?php\nnamespace Icecave\\Collections;\n\n\/**\n * A Sequence is a variable-sized collection whose elements are arranged in a strict linear order.\n *\/\ninterface SequenceInterface extends CollectionInterface\n{\n    \/**\n     * Fetch the first element in the sequence.\n     *\n     * @return mixed                              The first element in the sequence.\n     * @throws Exception\\EmptyCollectionException if the collection is empty.\n     *\/\n    public function front();\n\n    \/**\n     * Fetch the first element in the sequence.\n     *\n     * @param mixed &$element Assigned the element at the front of collection.\n     *\n     * @return boolean True is the element exists and was assigned to $element; otherwise, false.\n     *\/\n    public function tryFront(&$element);\n\n    \/**\n     * Fetch the last element in the sequence.\n     *\n     * @return mixed                              The first element in the sequence.\n     * @throws Exception\\EmptyCollectionException if the collection is empty.\n     *\/\n    public function back();\n\n    \/**\n     * Fetch the last element in the sequence.\n     *\n     * @param mixed &$element Assigned the element at the front of collection.\n     *\n     * @return boolean True is the element exists and was assigned to $element; otherwise, false.\n     *\/\n    public function tryBack(&$element);\n\n    \/**\n     * Create a new sequence with the elements from this sequence in sorted order.\n     *\n     * It is not guaranteed that the concrete type of the sorted collection will match this collection.\n     *\n     * @param callable|null $comparator A strcmp style comparator function.\n     *\n     * @return SequenceInterface\n     *\/\n    public function sort($comparator = null);\n\n    \/**\n     * Create a new sequence with the elements from this sequence in reverse order.\n     *\n     * It is not guaranteed that the concrete type of the reversed collection will match this collection.\n     *\n     * @return SequenceInterface The reversed sequence.\n     *\/\n    public function reverse();\n\n    \/**\n     * Create a new sequence by appending the elements in the given sequence to this sequence.\n     *\n     * @param mixed<mixed> $sequence       The sequence to append.\n     * @param mixed<mixed> $additional,... Additional sequences to append.\n     *\n     * @return SequenceInterface A new sequence containing all elements from this sequence and $sequence.\n     *\/\n    public function join($sequence);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Collections\/Set.php","source":"<?php\nnamespace Icecave\\Collections;\n\nuse Countable;\nuse Icecave\\Collections\\Iterator\\Traits;\nuse Icecave\\Collections\\TypeCheck\\TypeCheck;\nuse Icecave\\Repr\\Repr;\nuse InvalidArgumentException;\nuse IteratorAggregate;\nuse Serializable;\n\n\/**\n * An iterable collection with unique elements.\n *\/\nclass Set implements MutableIterableInterface, Countable, IteratorAggregate, Serializable\n{\n    \/**\n     * @param mixed<mixed>|null $collection An iterable type containing the elements to include in this set, or null to create an empty set.\n     * @param callable|null     $comparator The function to use for comparing elements, or null to use the default.\n     *\/\n    public function __construct($collection = null, $comparator = null)\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n\n        if (null === $comparator) {\n            $comparator = new Utility\\ObjectIdentityComparator;\n        }\n\n        $this->comparator = $comparator;\n        $this->elements = new Vector;\n\n        if (null !== $collection) {\n            foreach ($collection as $element) {\n                $this->add($element);\n            }\n        }\n    }\n\n    public function __clone()\n    {\n        $this->typeCheck->validateClone(func_get_args());\n\n        $this->elements = clone $this->elements;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of CollectionInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Fetch the number of elements in the collection.\n     *\n     * @see Set::isEmpty()\n     *\n     * @return integer The number of elements in the collection.\n     *\/\n    public function size()\n    {\n        $this->typeCheck->size(func_get_args());\n\n        return $this->elements->size();\n    }\n\n    \/**\n     * Check if the collection is empty.\n     *\n     * @return boolean True if the collection is empty; otherwise, false.\n     *\/\n    public function isEmpty()\n    {\n        $this->typeCheck->isEmpty(func_get_args());\n\n        return $this->elements->isEmpty();\n    }\n\n    \/**\n     * Fetch a string representation of the collection.\n     *\n     * The string may not describe all elements of the collection, but should at least\n     * provide information on the type and state of the collection.\n     *\n     * @return string A string representation of the collection.\n     *\/\n    public function __toString()\n    {\n        if ($this->isEmpty()) {\n            return '<Set 0>';\n        } elseif ($this->size() > 3) {\n            $format = '<Set %d [%s, ...]>';\n        } else {\n            $format = '<Set %d [%s]>';\n        }\n\n        return sprintf(\n            $format,\n            $this->size(),\n            implode(\n                ', ',\n                $this\n                    ->elements\n                    ->slice(0, 3)\n                    ->map('Icecave\\Repr\\Repr::repr')\n                    ->elements()\n            )\n        );\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of MutableCollectionInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Remove all elements from the collection.\n     *\/\n    public function clear()\n    {\n        $this->typeCheck->clear(func_get_args());\n\n        $this->elements->clear();\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of IteratorTraitsProvider \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Return traits describing the collection's iteration capabilities.\n     *\n     * @return Traits\n     *\/\n    public function iteratorTraits()\n    {\n        $this->typeCheck->iteratorTraits(func_get_args());\n\n        return new Traits(true, true);\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of IterableInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Fetch a native array containing the elements in the collection.\n     *\n     * @return array An array containing the elements in the collection.\n     *\/\n    public function elements()\n    {\n        $this->typeCheck->elements(func_get_args());\n\n        return $this->elements->elements();\n    }\n\n    \/**\n     * Check if the collection contains an element with the given value.\n     *\n     * @param mixed $element The value to check.\n     *\n     * @return boolean True if the collection contains $element; otherwise, false.\n     *\/\n    public function contains($element)\n    {\n        $this->typeCheck->contains(func_get_args());\n\n        return null !== $this->binarySearch($element);\n    }\n\n    \/**\n     * Fetch a new collection with a subset of the elements from this collection.\n     *\n     * The predicate must be a callable with the following signature:\n     *  function (mixed $element) { return $true_to_retain_element; }\n     *\n     * @param callable|null $predicate A predicate function used to determine which elements to include, or null to include all non-null elements.\n     *\n     * @return Set The filtered collection.\n     *\/\n    public function filter($predicate = null)\n    {\n        $this->typeCheck->filter(func_get_args());\n\n        $result = $this->createSet();\n        $result->elements = $this->elements->filter($predicate);\n\n        return $result;\n    }\n\n    \/**\n     * Produce a new collection by applying a transformation to each element.\n     *\n     * The new elements produced by the transform need not be of the same type.\n     * It is not guaranteed that the concrete type of the resulting collection will match this collection.\n     *\n     * The transform must be a callable with the following signature:\n     *  function (mixed $element) { return $new_element; }\n     *\n     * @param callable $transform The transform to apply to each element.\n     *\n     * @return IterableInterface A new collection produced by applying $transform to each element in this collection.\n     *\/\n    public function map($transform)\n    {\n        $this->typeCheck->map(func_get_args());\n\n        $result = $this->createSet();\n        $result->addMany(\n            $this->elements->map($transform)\n        );\n\n        return $result;\n    }\n\n    \/**\n     * Partitions this collection into two collections according to a predicate.\n     *\n     * It is not guaranteed that the concrete type of the partitioned collections will match this collection.\n     *\n     * @param callable $predicate A predicate function used to determine which partitioned collection to place the elements in.\n     *\n     * @return tuple<IterableInterface,IterableInterface> A 2-tuple containing the partitioned collections. The first collection contains the element for which the predicate returned true.\n     *\/\n    public function partition($predicate)\n    {\n        $this->typeCheck->partition(func_get_args());\n\n        $left  = $this->createSet();\n        $right = $this->createSet();\n\n        foreach ($this->elements as $element) {\n            if (call_user_func($predicate, $element)) {\n                $left->elements->pushBack($element);\n            } else {\n                $right->elements->pushBack($element);\n            }\n        }\n\n        return array($left, $right);\n    }\n\n    \/**\n     * Invokes the given callback on every element in the collection.\n     *\n     * This method behaves the same as {@see IterableInterface::map()} except that the return value of the callback is not retained.\n     *\n     * @param callable $callback The callback to invoke with each element.\n     *\/\n    public function each($callback)\n    {\n        $this->typeCheck->each(func_get_args());\n\n        $this->elements->each($callback);\n    }\n\n    \/**\n     * Returns true if the given predicate returns true for all elements.\n     *\n     * The loop is short-circuited, exiting after the first element for which the predicate returns false.\n     *\n     * @param callable $predicate\n     *\n     * @return boolean True if $predicate($element) returns true for all elements; otherwise, false.\n     *\/\n    public function all($predicate)\n    {\n        $this->typeCheck->all(func_get_args());\n\n        return $this->elements->all($predicate);\n    }\n\n    \/**\n     * Returns true if the given predicate returns true for any element.\n     *\n     * The loop is short-circuited, exiting after the first element for which the predicate returns false.\n     *\n     * @param callable $predicate\n     *\n     * @return boolean True if $predicate($element) returns true for any element; otherwise, false.\n     *\/\n    public function any($predicate)\n    {\n        $this->typeCheck->any(func_get_args());\n\n        return $this->elements->any($predicate);\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of MutableIterableInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Filter this collection in-place.\n     *\n     * The predicate must be a callable with the following signature:\n     *  function (mixed $element) { return $true_to_retain_element; }\n     *\n     * @param callable|null $predicate A predicate function used to determine which elements to retain, or null to retain all elements with non-null values.\n     *\/\n    public function filterInPlace($predicate = null)\n    {\n        $this->typeCheck->filterInPlace(func_get_args());\n\n        $this->elements->filterInPlace($predicate);\n    }\n\n    \/**\n     * Replace each element in the collection with the result of a transformation on that element.\n     *\n     * The new elements produced by the transform must be the same type.\n     *\n     * The transform must be a callable with the following signature:\n     *  function (mixed $element) { return $element; }\n     *\n     * @param callable $transform The transform to apply to each element.\n     *\/\n    public function mapInPlace($transform)\n    {\n        $this->typeCheck->mapInPlace(func_get_args());\n\n        $this->elements->mapInPlace($transform);\n        $this->elements->sortInPlace($this->comparator);\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of Countable \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    public function count()\n    {\n        $this->typeCheck->count(func_get_args());\n\n        return $this->size();\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of IteratorAggregate \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    public function getIterator()\n    {\n        $this->typeCheck->getIterator(func_get_args());\n\n        return $this->elements;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of Serializable \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Serialize the collection.\n     *\n     * @return string The serialized data.\n     *\/\n    public function serialize()\n    {\n        $this->typeCheck->serialize(func_get_args());\n\n        return serialize(\n            array(\n                $this->elements(),\n                $this->comparator\n            )\n        );\n    }\n\n    \/**\n     * Unserialize collection data.\n     *\n     * @param string $packet The serialized data.\n     *\/\n    public function unserialize($packet)\n    {\n        TypeCheck::get(__CLASS__)->unserialize(func_get_args());\n\n        list($elements, $comparator) = unserialize($packet);\n        $this->__construct(null, $comparator);\n        $this->elements->append($elements);\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Model specific methods \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Return the first of the given elements that is contained in the set.\n     *\n     * @param mixed $element        The element to search for.\n     * @param mixed $additional,... Additional elements to search for.\n     *\n     * @return mixed                         The first of the given elements that is contained in the set.\n     * @throws Exception\\UnknownKeyException if none of the elements exist.\n     *\/\n    public function cascade($element)\n    {\n        $this->typeCheck->cascade(func_get_args());\n\n        return $this->cascadeIterable(func_get_args());\n    }\n\n    \/**\n     * Return the first of the given elements that is contained in the set, or a default if none are found.\n     *\n     * @param mixed $default        The default value to return if no such elements exist.\n     * @param mixed $element        The element to search for.\n     * @param mixed $additional,... Additional elements to search for.\n     *\n     * @return mixed The first of the given elements that is contained in the set, or $default if none are found.\n     *\/\n    public function cascadeWithDefault($default, $element)\n    {\n        $this->typeCheck->cascadeWithDefault(func_get_args());\n\n        $elements = func_get_args();\n        $default = array_shift($elements);\n\n        return $this->cascadeIterableWithDefault($default, $elements);\n    }\n\n    \/**\n     * Return the first of the given elements that is contained in the set.\n     *\n     * Behaves as per {@see Set::cascade()} except that the elements are provided as\n     * a traversable (eg, array) instead of via a variable argument list.\n     *\n     * @param mixed<mixed> $elements The list of elements.\n     *\n     * @return mixed                         The first of the given elements that is contained in the set.\n     * @throws Exception\\UnknownKeyException if none of the elements exist.\n     *\/\n    public function cascadeIterable($elements)\n    {\n        $this->typeCheck->cascadeIterable(func_get_args());\n\n        foreach ($elements as $element) {\n            if ($this->contains($element)) {\n                return $element;\n            }\n        }\n\n        throw new Exception\\UnknownKeyException($element);\n    }\n\n    \/**\n     * Return the first of the given elements that is contained in the set, or a default if none are found.\n     *\n     * Behaves as per {@see Set::cascadeDefault()} except that the elements are provided as\n     * a traversable (eg, array) instead of via a variable argument list.\n     *\n     * @param mixed        $default  The default value to return if no such elements exist.\n     * @param mixed<mixed> $elements The list of elements.\n     *\n     * @return mixed The first of the given elements that is contained in the set, or $default if none are found.\n     *\/\n    public function cascadeIterableWithDefault($default, $elements)\n    {\n        $this->typeCheck->cascadeIterableWithDefault(func_get_args());\n\n        foreach ($elements as $element) {\n            if ($this->contains($element)) {\n                return $element;\n            }\n        }\n\n        return $default;\n    }\n\n    \/**\n     * Add an element to the set.\n     *\n     * @param mixed $element The element to add.\n     *\n     * @return boolean True if the element was added to the set, or false if the set already contained the element.\n     *\/\n    public function add($element)\n    {\n        $this->typeCheck->add(func_get_args());\n\n        $insertIndex = null;\n\n        if (null !== $this->binarySearch($element, 0, $insertIndex)) {\n            return false;\n        }\n\n        $this->elements->insert($insertIndex, $element);\n\n        return true;\n    }\n\n    \/**\n     * Add multiple elements to the set.\n     *\n     * @see Set::unionInPlace() may be faster when adding all elements from a another set.\n     *\n     * @param mixed<mixed> $elements The elements to add.\n     *\/\n    public function addMany($elements)\n    {\n        $this->typeCheck->addMany(func_get_args());\n\n        foreach ($elements as $element) {\n            $this->add($element);\n        }\n    }\n\n    \/**\n     * Remove an element from the set, if it exists.\n     *\n     * @param mixed $element The element to remove.\n     *\n     * @return boolean True if the element was removed from the set, or false if the set dot not contain the element.\n     *\/\n    public function remove($element)\n    {\n        $this->typeCheck->remove(func_get_args());\n\n        $index = $this->binarySearch($element);\n\n        if (null === $index) {\n            return false;\n        }\n\n        $this->elements->remove($index);\n\n        return true;\n    }\n\n    \/**\n     * Remove multiple elements from the set.\n     *\n     * @see Set::diffInPlace() may be faster when removing all elements from a another set.\n     *\n     * @param mixed<mixed> $elements The elements to remote.\n     *\/\n    public function removeMany($elements)\n    {\n        $this->typeCheck->removeMany(func_get_args());\n\n        foreach ($elements as $element) {\n            $this->remove($element);\n        }\n    }\n\n    \/**\n     * Check if this set is equal to another.\n     *\n     * @param Set $set The set to compare against.\n     *\n     * @return boolean True if this set contains the same elements as $set; otherwise false.\n     *\/\n    public function isEqualSet(Set $set)\n    {\n        $this->typeCheck->isEqualSet(func_get_args());\n\n        $this->assertCompatible($set);\n\n        if ($this->size() !== $set->size()) {\n            return false;\n        } elseif ($this->isEmpty()) {\n            return true;\n        }\n\n        \/\/ All elements in $set are greater than all elements in $this ...\n        if ($this->compareElements($this->elements->back(), $set->elements->front()) < 0) {\n            return false;\n        \/\/ All elements in $this are greater than all elements in $set ...\n        } elseif ($this->compareElements($set->elements->back(), $this->elements->front()) < 0) {\n            return false;\n        }\n\n        foreach ($this->elements as $index => $element) {\n            if (0 !== $this->compareElements($element, $set->elements[$index])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \/**\n     * Check if this set is a superset of another.\n     *\n     * @param Set $set The set to compare against.\n     *\n     * @return boolean True if this set contains all of the elements in $set; otherwise, false.\n     *\/\n    public function isSuperSet(Set $set)\n    {\n        $this->typeCheck->isSuperSet(func_get_args());\n\n        $this->assertCompatible($set);\n\n        \/\/ Everything is a super-set of the empty set ...\n        if ($set->isEmpty()) {\n            return true;\n        \/\/ $this cannot be a superset if it has less elements ...\n        } elseif ($this->size() < $set->size()) {\n            return false;\n        \/\/ $this can not be a superset if its first element is greater than the first element of $set ...\n        } elseif ($this->compareElements($this->elements->front(), $set->elements->front()) > 0) {\n            return false;\n        \/\/ $this can not be a superset if its last element is less than the last element of $set ...\n        } elseif ($this->compareElements($this->elements->back(), $set->elements->back()) < 0) {\n            return false;\n        }\n\n        $lhsIndex = 0;\n        $rhsIndex = 0;\n\n        while (true) {\n            $cmp = $this->compareElements(\n                $this->elements[$lhsIndex++],\n                $set->elements[$rhsIndex]\n            );\n\n            if ($cmp > 0) {\n                return false;\n            } elseif (0 === $cmp && ++$rhsIndex === $set->size()) {\n                break;\n            }\n        };\n\n        return true;\n    }\n\n    \/**\n     * Check if this set is a subset of another.\n     *\n     * @param Set $set The set to compare against.\n     *\n     * @return boolean True if this set contains only elements present in $set; otherwise, false.\n     *\/\n    public function isSubSet(Set $set)\n    {\n        $this->typeCheck->isSubSet(func_get_args());\n\n        $this->assertCompatible($set);\n\n        return $set->isSuperSet($this);\n    }\n\n    \/**\n     * Check if this set is a proper superset of another.\n     *\n     * @param Set $set The set to compare against.\n     *\n     * @return boolean True if this set contains all of elements in $set, but is not equal to $set; otherwise, false.\n     *\/\n    public function isProperSuperSet(Set $set)\n    {\n        $this->typeCheck->isProperSuperSet(func_get_args());\n\n        $this->assertCompatible($set);\n\n        \/\/ Everything is a super-set of the empty set ...\n        if (!$this->isEmpty() && $set->isEmpty()) {\n            return true;\n        \/\/ $this cannot be a superset if it has less or same number of elements ...\n        } elseif ($this->size() <= $set->size()) {\n            return false;\n        } else {\n            return $this->isSuperSet($set);\n        }\n    }\n\n    \/**\n     * Check if this set is a proper subset of another.\n     *\n     * @param Set $set The set to compare against.\n     *\n     * @return boolean True if this set contains only elements present in $set, but is not equal to $set; otherwise, false.\n     *\/\n    public function isProperSubSet(Set $set)\n    {\n        $this->typeCheck->isProperSubSet(func_get_args());\n\n        $this->assertCompatible($set);\n\n        return $set->isProperSuperSet($this);\n    }\n\n    \/**\n     * Check if this set is intersecting another.\n     *\n     * @param Set $set The set to compare against.\n     *\n     * @return boolean True if this set contains one or more elements present in $set; otherwise false.\n     *\/\n    public function isIntersecting(Set $set)\n    {\n        $this->typeCheck->isIntersecting(func_get_args());\n\n        $this->assertCompatible($set);\n\n        \/\/ Nothing intersects with the empty set ...\n        if ($this->isEmpty() || $set->isEmpty()) {\n            return false;\n        }\n\n        $cmp = $this->compareElements(\n            $this->elements->back(),\n            $set->elements->front()\n        );\n\n        \/\/ All elements in $set are greater than all elements in $this ...\n        if ($cmp < 0) {\n            return false;\n        \/\/ Tail of $this equal to head of $set ...\n        } elseif (0 === $cmp) {\n            return true;\n        }\n\n        $cmp = $this->compareElements(\n            $set->elements->back(),\n            $this->elements->front()\n        );\n\n        \/\/ All elements in $this are greater than all elements in $set ...\n        if ($cmp < 0) {\n            return false;\n        \/\/ Tail of $set equal to head of $this ...\n        } elseif (0 === $cmp) {\n            return true;\n        }\n\n        $lhsIndex = 0;\n        $rhsIndex = 0;\n\n        while ($lhsIndex !== $this->size() && $rhsIndex !== $set->size()) {\n            $cmp = $this->compareElements(\n                $this->elements[$lhsIndex],\n                $set->elements[$rhsIndex]\n            );\n\n            if ($cmp < 0) {\n                ++$lhsIndex;\n            } elseif ($cmp > 0) {\n                ++$rhsIndex;\n            } else {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    \/**\n     * Compute the union of this set and another.\n     *\n     * @param Set $set The second set.\n     *\n     * @return Set A set containing all elements of $this and $elements.\n     *\/\n    public function union(Set $set)\n    {\n        $this->typeCheck->union(func_get_args());\n\n        $this->assertCompatible($set);\n\n        \/\/\n        \/\/ Union with an empty set is always the non-empty set ...\n        \/\/\n        if ($this->isEmpty()) {\n            return clone $set;\n        } elseif ($set->isEmpty()) {\n            return clone $this;\n        }\n\n        $result = $this->createSet();\n        $result->elements->reserve(max($this->size(), $set->size()));\n\n        \/\/\n        \/\/ Compare tail\/head ...\n        \/\/\n        $cmp = $this->compareElements($this->elements->back(), $set->elements->front());\n\n        \/\/ All elements in $set are greater than all elements in $this ...\n        if ($cmp < 0) {\n            $result->elements->append($this->elements);\n            $result->elements->append($set->elements);\n\n            return $result;\n        \/\/ Tail of $this equal to head of $set ...\n        } elseif (0 === $cmp) {\n            $result->elements->append($this->elements);\n            $result->elements->append($set->elements->slice(1));\n\n            return $result;\n        }\n\n        \/\/\n        \/\/ Compare head\/tail ...\n        \/\/\n        $cmp = $this->compareElements($set->elements->back(), $this->elements->front());\n\n        \/\/ All elements in $this are greater than all elements in $set ...\n        if ($cmp < 0) {\n            $result->elements->append($set->elements);\n            $result->elements->append($this->elements);\n\n            return $result;\n        \/\/ Tail of $set equal to head of $this ...\n        } elseif (0 === $cmp) {\n            $result->elements->append($set->elements);\n            $result->elements->append($this->elements->slice(1));\n\n            return $result;\n        }\n\n        \/\/\n        \/\/ Merge both sides ...\n        \/\/\n        $lhsIndex = 0;\n        $rhsIndex = 0;\n\n        while (true) {\n            $cmp = $this->compareElements(\n                $this->elements[$lhsIndex],\n                $set->elements[$rhsIndex]\n            );\n\n            \/\/ Element from $this is less, add it next ..\n            if ($cmp < 0) {\n                $result->elements->pushBack($this->elements[$lhsIndex]);\n                ++$lhsIndex;\n\n            \/\/ Element from $set is less, add it next ..\n            } elseif ($cmp > 0) {\n                $result->elements->pushBack($set->elements[$rhsIndex]);\n                ++$rhsIndex;\n\n            \/\/ Elements are equivalent, add to the result and advance index for both sides ...\n            } else {\n                $result->elements->pushBack($this->elements[$lhsIndex]);\n                ++$lhsIndex;\n                ++$rhsIndex;\n            }\n\n            \/\/ Reached the end of $this first, append the rest of $set ...\n            if ($lhsIndex === $this->size()) {\n                if ($rhsIndex !== $set->size()) {\n                    $result->elements->append($set->elements->slice($rhsIndex));\n                }\n                break;\n            \/\/ Reached the end of $set first, append the rest of $this ...\n            } elseif ($rhsIndex === $set->size()) {\n                $result->elements->append($this->elements->slice($lhsIndex));\n                break;\n            }\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Compute the union of this set and another, in place.\n     *\n     * @param Set $set The second set.\n     *\/\n    public function unionInPlace(Set $set)\n    {\n        $this->typeCheck->unionInPlace(func_get_args());\n\n        $this->assertCompatible($set);\n\n        \/\/\n        \/\/ Union with an empty set is always the non-empty set ...\n        \/\/\n        if ($this->isEmpty()) {\n            $this->elements->append($set->elements);\n\n            return;\n        } elseif ($set->isEmpty()) {\n            return;\n        }\n\n        $this->elements->reserve($set->size());\n\n        \/\/\n        \/\/ Compare tail\/head ...\n        \/\/\n        $cmp = $this->compareElements($this->elements->back(), $set->elements->front());\n\n        \/\/ All elements in $set are greater than all elements in $this ...\n        if ($cmp < 0) {\n            $this->elements->append($set->elements);\n\n            return;\n        \/\/ Tail of $this equal to head of $set ...\n        } elseif (0 === $cmp) {\n            $this->elements->append($set->elements->slice(1));\n\n            return;\n        }\n\n        \/\/\n        \/\/ Compare head\/tail ...\n        \/\/\n        $cmp = $this->compareElements($set->elements->back(), $this->elements->front());\n\n        \/\/ All elements in $this are greater than all elements in $set ...\n        if ($cmp < 0) {\n            $this->elements->insertMany(0, $set->elements);\n\n            return;\n        \/\/ Tail of $set equal to head of $this ...\n        } elseif (0 === $cmp) {\n            $this->elements->insertMany(0, $set->elements->range(0, -1));\n\n            return;\n        }\n\n        \/\/\n        \/\/ Merge elements from $set into $this ...\n        \/\/\n\n        $lhsIndex = 0;\n        $rhsIndex = 0;\n\n        while (true) {\n            $cmp = $this->compareElements(\n                $this->elements[$lhsIndex],\n                $set->elements[$rhsIndex]\n            );\n\n            \/\/ Element from $set is less, add it next ..\n            if ($cmp > 0) {\n                $this->elements->insert($lhsIndex, $set->elements[$rhsIndex]);\n                ++$rhsIndex;\n\n            \/\/ Elements are equivalent ...\n            } elseif (0 === $cmp) {\n                ++$rhsIndex;\n            }\n\n            if (++$lhsIndex === $this->size()) {\n                if ($rhsIndex !== $set->size()) {\n                    $this->elements->append($set->elements->slice($rhsIndex));\n                }\n                break;\n            } elseif ($rhsIndex === $set->size()) {\n                break;\n            }\n        }\n    }\n\n    \/**\n     * Compute the intersection of this set and another.\n     *\n     * @param Set $set The second set.\n     *\n     * @return Set A set containing only the elements present in $this and $elements.\n     *\/\n    public function intersect(Set $set)\n    {\n        $this->typeCheck->intersect(func_get_args());\n\n        $this->assertCompatible($set);\n\n        \/\/\n        \/\/ Intersection with empty set is always empty ..\n        \/\/\n        if ($this->isEmpty() || $set->isEmpty()) {\n            return $this->createSet();\n        }\n\n        \/\/\n        \/\/ Compare tail\/head ...\n        \/\/\n        $cmp = $this->compareElements($this->elements->back(), $set->elements->front());\n\n        \/\/ All elements in $set are greater than all elements in $this ...\n        if ($cmp < 0) {\n            return $this->createSet();\n        \/\/ Tail of $this equal to head of $set ...\n        } elseif (0 === $cmp) {\n            return $this->createSet(\n                array($this->elements->back())\n            );\n        }\n\n        \/\/\n        \/\/ Compare head\/tail ...\n        \/\/\n        $cmp = $this->compareElements($set->elements->back(), $this->elements->front());\n\n        \/\/ All elements in $this are greater than all elements in $set ...\n        if ($cmp < 0) {\n            return $this->createSet();\n        \/\/ Tail of $set equal to head of $this ...\n        } elseif (0 === $cmp) {\n            return $this->createSet(\n                array($this->elements->front())\n            );\n        }\n\n        \/\/\n        \/\/ Build intersection from both sides ...\n        \/\/\n        $lhsIndex = 0;\n        $rhsIndex = 0;\n\n        $result = $this->createSet();\n\n        while ($lhsIndex !== $this->size() && $rhsIndex !== $set->size()) {\n            $cmp = $this->compareElements($this->elements[$lhsIndex], $set->elements[$rhsIndex]);\n\n            if ($cmp < 0) {\n                ++$lhsIndex;\n            } elseif ($cmp > 0) {\n                ++$rhsIndex;\n            } else {\n                $result->elements->pushBack($this->elements[$lhsIndex]);\n                ++$lhsIndex;\n                ++$rhsIndex;\n            }\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Compute the intersection of this set and another, in place.\n     *\n     * @param Set $set The second set.\n     *\/\n    public function intersectInPlace(Set $set)\n    {\n        $this->typeCheck->intersectInPlace(func_get_args());\n\n        $this->assertCompatible($set);\n\n        \/\/\n        \/\/ Intersection with empty set is always empty set ...\n        \/\/\n        if ($this->isEmpty()) {\n            return;\n        } elseif ($set->isEmpty()) {\n            $this->clear();\n\n            return;\n        }\n\n        \/\/\n        \/\/ Compare tail\/head ...\n        \/\/\n        $cmp = $this->compareElements($this->elements->back(), $set->elements->front());\n\n        \/\/ All elements in $set are greater than all elements in $this ...\n        if ($cmp < 0) {\n            $this->clear();\n\n            return;\n        \/\/ Tail of $this equal to head of $set ...\n        } elseif (0 === $cmp) {\n            $this->elements->popfront();\n\n            return;\n        }\n\n        \/\/\n        \/\/ Compare head\/tail ...\n        \/\/\n        $cmp = $this->compareElements($set->elements->back(), $this->elements->front());\n\n        \/\/ All elements in $this are greater than all elements in $set ...\n        if ($cmp < 0) {\n            $this->clear();\n\n            return;\n        \/\/ Tail of $set equal to head of $this ...\n        } elseif (0 === $cmp) {\n            $this->elements->popBack();\n\n            return;\n        }\n\n        \/\/\n        \/\/ Remove elements not in $set ...\n        \/\/\n        $lhsIndex = $this->size() - 1;\n        $rhsIndex = $set->size() - 1;\n\n        while ($lhsIndex >= 0 && $rhsIndex >= 0) {\n            $cmp = $this->compareElements($this->elements[$lhsIndex], $set->elements[$rhsIndex]);\n\n            if ($cmp < 0) {\n                --$rhsIndex;\n            } elseif ($cmp > 0) {\n                $this->elements->remove($lhsIndex--);\n            } else {\n                --$lhsIndex;\n                --$rhsIndex;\n            }\n        }\n\n        \/\/ Remove any remaining elements ...\n        if ($lhsIndex >= 0) {\n            $this->elements->removeMany(0, $lhsIndex + 1);\n        }\n    }\n\n    \/**\n     * Compute the difference (or complement) of this set and another.\n     *\n     * @param Set $set The second set.\n     *\n     * @return Set A set containing only the elements present in $this, but not $elements.\n     *\/\n    public function diff(Set $set)\n    {\n        $this->typeCheck->diff(func_get_args());\n\n        $this->assertCompatible($set);\n\n        \/\/\n        \/\/ Empty set produces empty set ...\n        \/\/\n        if ($this->isEmpty()) {\n            return $this->createSet();\n        }\n\n        \/\/\n        \/\/ Diff to empty set produces $this ...\n        \/\/\n        if ($set->isEmpty()) {\n            return clone $this;\n        }\n\n        \/\/\n        \/\/ Compare tail\/head ...\n        \/\/\n        $cmp = $this->compareElements($this->elements->back(), $set->elements->front());\n\n        \/\/ All elements in $set are greater than all elements in $this ...\n        if ($cmp < 0) {\n            return clone $this;\n        \/\/ Tail of $this equal to head of $set ...\n        } elseif (0 === $cmp) {\n            $result = clone $this;\n            $result->elements->popBack();\n\n            return $result;\n        }\n\n        \/\/\n        \/\/ Compare head\/tail ...\n        \/\/\n        $cmp = $this->compareElements($set->elements->back(), $this->elements->front());\n\n        \/\/ All elements in $this are greater than all elements in $set ...\n        if ($cmp < 0) {\n            return clone $this;\n        \/\/ Tail of $set equal to head of $this ...\n        } elseif (0 === $cmp) {\n            $result = clone $this;\n            $result->elements->popFront();\n\n            return $result;\n        }\n\n        \/\/\n        \/\/ Build diff from both sides ...\n        \/\/\n        $lhsIndex = 0;\n        $rhsIndex = 0;\n\n        $result = $this->createSet();\n        $result->elements->reserve($this->size() - $set->size());\n\n         while (true) {\n            $cmp = $this->compareElements($this->elements[$lhsIndex], $set->elements[$rhsIndex]);\n\n            if ($cmp < 0) {\n                $result->elements->pushBack($this->elements[$lhsIndex]);\n                ++$lhsIndex;\n            } elseif ($cmp > 0) {\n                ++$rhsIndex;\n            } else {\n                ++$lhsIndex;\n                ++$rhsIndex;\n            }\n\n            if ($rhsIndex === $set->size()) {\n                if ($lhsIndex !== $this->size()) {\n                    $result->elements->append($this->elements->slice($lhsIndex));\n                }\n                break;\n            } elseif ($lhsIndex === $this->size()) {\n                break;\n            }\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Compute the difference (or complement) of this set and another, in place.\n     *\n     * @param Set $set The second set.\n     *\/\n    public function diffInPlace(Set $set)\n    {\n        $this->typeCheck->diffInPlace(func_get_args());\n\n        $this->assertCompatible($set);\n\n        \/\/\n        \/\/ Empty set produces empty set ...\n        \/\/ Diff to empty set produces $this ...\n        \/\/\n        if ($this->isEmpty() || $set->isEmpty()) {\n            return;\n        }\n\n        \/\/\n        \/\/ Compare tail\/head ...\n        \/\/\n        $cmp = $this->compareElements($this->elements->back(), $set->elements->front());\n\n        \/\/ All elements in $set are greater than all elements in $this ...\n        if ($cmp < 0) {\n            return;\n        \/\/ Tail of $this equal to head of $set ...\n        } elseif (0 === $cmp) {\n            $this->elements->popBack();\n\n            return;\n        }\n\n        \/\/\n        \/\/ Compare head\/tail ...\n        \/\/\n        $cmp = $this->compareElements($set->elements->back(), $this->elements->front());\n\n        \/\/ All elements in $this are greater than all elements in $set ...\n        if ($cmp < 0) {\n            return;\n        \/\/ Tail of $set equal to head of $this ...\n        } elseif (0 === $cmp) {\n            $this->elements->popFront();\n\n            return;\n        }\n\n        \/\/\n        \/\/ Remove elements that are in $set ...\n        \/\/\n        $lhsIndex = $this->size() - 1;\n        $rhsIndex = $set->size() - 1;\n\n        while ($lhsIndex >= 0 && $rhsIndex >= 0) {\n            $cmp = $this->compareElements($this->elements[$lhsIndex], $set->elements[$rhsIndex]);\n\n            if ($cmp < 0) {\n                --$rhsIndex;\n            } elseif ($cmp > 0) {\n                --$lhsIndex;\n            } else {\n                $this->elements->remove($lhsIndex);\n                --$lhsIndex;\n                --$rhsIndex;\n            }\n        }\n    }\n\n    \/**\n     * Compute the symmetric difference (or complement) of this set and another.\n     *\n     * The symmetric difference is the set of elements which are in either of the sets and not in their intersection.\n     *\n     * @param Set $set The second set.\n     *\n     * @return Set A set containing only the elements present in $this, or $elements, but not both.\n     *\/\n    public function symmetricDiff(Set $set)\n    {\n        $this->typeCheck->symmetricDiff(func_get_args());\n\n        $this->assertCompatible($set);\n\n        \/\/\n        \/\/ Symmetric diff with an empty set is always the non-empty set ...\n        \/\/\n        if ($this->isEmpty()) {\n            return clone $set;\n        } elseif ($set->isEmpty()) {\n            return clone $this;\n        }\n\n        $result = $this->createSet();\n\n        \/\/\n        \/\/ Compare tail\/head ...\n        \/\/\n        $cmp = $this->compareElements($this->elements->back(), $set->elements->front());\n\n        \/\/ All elements in $set are greater than all elements in $this ...\n        if ($cmp < 0) {\n            $result->elements->append($this->elements);\n            $result->elements->append($set->elements);\n\n            return $result;\n        \/\/ Tail of $this equal to head of $set ...\n        } elseif (0 === $cmp) {\n            $result->elements->append($this->elements->range(0, -1));\n            $result->elements->append($set->elements->slice(1));\n\n            return $result;\n        }\n\n        \/\/\n        \/\/ Compare head\/tail ...\n        \/\/\n        $cmp = $this->compareElements($set->elements->back(), $this->elements->front());\n\n        \/\/ All elements in $this are greater than all elements in $set ...\n        if ($cmp < 0) {\n            $result->elements->append($set->elements);\n            $result->elements->append($this->elements);\n\n            return $result;\n        \/\/ Tail of $set equal to head of $this ...\n        } elseif (0 === $cmp) {\n            $result->elements->append($set->elements->range(0, -1));\n            $result->elements->append($this->elements->slice(1));\n\n            return $result;\n        }\n\n        \/\/\n        \/\/ Build symmetric diff from both sides ...\n        \/\/\n        $lhsIndex = 0;\n        $rhsIndex = 0;\n\n        while (true) {\n            $cmp = $this->compareElements($this->elements[$lhsIndex], $set->elements[$rhsIndex]);\n\n            \/\/ Element from $this is less, add it next ..\n            if ($cmp < 0) {\n                $result->elements->pushBack($this->elements[$lhsIndex]);\n                ++$lhsIndex;\n\n            \/\/ Element from $set is less, add it next ..\n            } elseif ($cmp > 0) {\n                $result->elements->pushBack($set->elements[$rhsIndex]);\n                ++$rhsIndex;\n\n            \/\/ Elements are equivalent, add to the result and advance index for both sides ...\n            } else {\n                ++$lhsIndex;\n                ++$rhsIndex;\n            }\n\n            \/\/ Reached the end of $this first, append the rest of $set ...\n            if ($lhsIndex === $this->size()) {\n                if ($rhsIndex !== $set->size()) {\n                    $result->elements->append($set->elements->slice($rhsIndex));\n                }\n                break;\n            \/\/ Reached the end of $set first, append the rest of $this ...\n            } elseif ($rhsIndex === $set->size()) {\n                $result->elements->append($this->elements->slice($lhsIndex));\n                break;\n            }\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Compute the symmetric difference (or complement) of this set and another, in place.\n     *\n     * The symmetric difference is the set of elements which are in either of the sets and not in their intersection.\n     *\n     * @param Set $set The second set.\n     *\/\n    public function symmetricDiffInPlace(Set $set)\n    {\n        $this->typeCheck->symmetricDiffInPlace(func_get_args());\n\n        $this->assertCompatible($set);\n\n        \/\/\n        \/\/ Symmetric diff with an empty set is always the non-empty set ...\n        \/\/\n        if ($this->isEmpty()) {\n            $this->elements->append($set->elements);\n\n            return;\n        } elseif ($set->isEmpty()) {\n            return;\n        }\n\n        \/\/\n        \/\/ Compare tail\/head ...\n        \/\/\n        $cmp = $this->compareElements($this->elements->back(), $set->elements->front());\n\n        \/\/ All elements in $set are greater than all elements in $this ...\n        if ($cmp < 0) {\n            $this->elements->append($set->elements);\n\n            return;\n        \/\/ Tail of $this equal to head of $set ...\n        } elseif (0 === $cmp) {\n            $this->elements->popBack();\n            $this->elements->append($set->elements->slice(1));\n\n            return;\n        }\n\n        \/\/\n        \/\/ Compare head\/tail ...\n        \/\/\n        $cmp = $this->compareElements($set->elements->back(), $this->elements->front());\n\n        \/\/ All elements in $this are greater than all elements in $set ...\n        if ($cmp < 0) {\n            $this->elements->insertMany(0, $set->elements);\n\n            return;\n        \/\/ Tail of $set equal to head of $this ...\n        } elseif (0 === $cmp) {\n            $this->elements->popFront();\n            $this->elements->insertMany(0, $set->elements->range(0, -1));\n\n            return;\n        }\n\n        \/\/\n        \/\/ Add\/remove elements to build symmetric diff in place ...\n        \/\/\n        $lhsIndex = 0;\n        $rhsIndex = 0;\n\n        while (true) {\n            $cmp = $this->compareElements($this->elements[$lhsIndex], $set->elements[$rhsIndex]);\n\n            \/\/ Element from $this is less ...\n            if ($cmp < 0) {\n                ++$lhsIndex;\n\n            \/\/ Element from $set is less ...\n            } elseif ($cmp > 0) {\n                $this->elements->insert($lhsIndex, $set->elements[$rhsIndex]);\n                ++$lhsIndex;\n                ++$rhsIndex;\n\n            \/\/ Elements are equivalent, add to the result and advance index for both sides ...\n            } else {\n                $this->elements->remove($lhsIndex);\n                ++$rhsIndex;\n            }\n\n            \/\/ Reached the end of $this first, append the rest of $set ...\n            if ($lhsIndex === $this->size()) {\n                if ($rhsIndex !== $set->size()) {\n                    $this->elements->append($set->elements->slice($rhsIndex));\n                }\n                break;\n            \/\/ Reached the end of $set first, append the rest of $this ...\n            } elseif ($rhsIndex === $set->size()) {\n                break;\n            }\n        }\n    }\n\n    \/**\n     * @param mixed $lhs\n     * @param mixed $rhs\n     *\n     * @return integer\n     *\/\n    private function compareElements($lhs, $rhs)\n    {\n        return call_user_func($this->comparator, $lhs, $rhs);\n    }\n\n    \/**\n     * @param mixed<mixed>|null $elements\n     *\n     * @return Set\n     *\/\n    private function createSet($elements = null)\n    {\n        return new self($elements, $this->comparator);\n    }\n\n    \/**\n     * @param Set $set\n     *\/\n    private function assertCompatible(Set $set)\n    {\n        if ($set->comparator != $this->comparator) {\n            throw new InvalidArgumentException('The given set does not use the same hashing algorithm.');\n        }\n    }\n\n    \/**\n     * @param mixed        $element\n     * @param integer      $startIndex\n     * @param integer|null &$insertIndex\n     *\n     * @return integer|null\n     *\/\n    private function binarySearch($element, $startIndex = 0, &$insertIndex = null)\n    {\n        return Collection::binarySearch(\n            $this->elements,\n            $element,\n            $this->comparator,\n            $startIndex,\n            null,\n            $insertIndex\n        );\n    }\n\n    private $typeCheck;\n    private $comparator;\n    private $elements;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,189,null,189,184,184,null,189,189,null,189,184,156,184,184,189,null,null,null,12,null,12,12,null,null,null,null,null,null,null,null,null,null,null,null,null,null,125,null,125,null,null,null,null,null,null,null,null,null,178,null,178,null,null,null,null,null,null,null,null,null,null,null,null,1,1,1,1,1,1,null,null,1,1,1,1,1,1,null,1,1,1,1,1,null,null,null,null,null,null,null,null,null,null,null,7,null,7,7,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,121,null,121,null,null,null,null,null,null,null,null,null,null,null,8,null,8,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,null,1,1,1,1,1,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,2,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,2,2,2,2,null,null,null,null,null,null,null,null,null,2,null,2,2,2,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,3,3,2,null,3,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,2,2,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,199,null,199,null,199,4,null,null,199,null,199,null,null,null,null,null,null,null,null,null,null,null,204,null,204,176,204,204,null,null,null,null,null,null,null,null,null,null,3,null,3,null,3,1,null,null,3,null,3,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,1,null,null,null,null,null,null,null,null,null,null,14,null,14,null,13,7,6,1,null,null,null,5,2,null,5,2,null,null,3,3,2,15,1,null,1,null,null,null,null,null,null,null,null,null,null,null,32,null,32,null,null,31,4,null,27,7,null,20,4,null,16,4,null,null,12,12,null,12,12,12,12,12,null,12,6,12,6,null,12,null,6,null,null,null,null,null,null,null,null,null,null,null,14,null,14,null,13,null,null,null,null,null,null,null,null,null,null,null,27,null,27,null,null,26,2,null,24,19,null,5,null,null,null,null,null,null,null,null,null,null,null,null,14,null,14,null,13,null,null,null,null,null,null,null,null,null,null,null,14,null,14,null,null,13,3,null,null,10,10,10,10,null,null,10,2,null,10,2,null,null,10,10,10,10,null,null,10,2,null,8,2,null,null,6,6,null,6,6,6,6,6,null,6,3,6,3,3,4,null,3,null,2,null,null,null,null,null,null,null,null,null,null,null,14,null,14,null,null,null,null,13,2,11,1,null,null,10,10,null,null,null,null,10,null,null,10,1,1,null,1,null,9,1,1,null,1,null,null,null,null,null,8,null,null,8,1,1,null,1,null,7,1,1,null,1,null,null,null,null,null,6,6,null,6,6,6,6,6,null,null,6,3,3,null,null,6,3,3,null,null,3,4,4,4,null,null,null,6,3,2,2,3,null,6,3,3,null,6,null,6,null,null,null,null,null,null,null,null,null,14,null,14,null,null,null,null,13,2,null,2,11,1,null,null,10,null,null,null,null,10,null,null,10,1,null,1,null,9,1,null,1,null,null,null,null,null,8,null,null,8,1,null,1,null,7,1,null,1,null,null,null,null,null,null,6,6,null,6,6,6,6,6,null,null,6,3,3,null,null,6,4,4,null,6,3,2,2,3,6,3,null,6,6,null,null,null,null,null,null,null,null,null,null,18,null,14,null,null,null,null,13,3,null,null,null,null,null,10,null,null,10,1,null,9,1,1,1,null,null,null,null,null,8,null,null,8,1,null,7,1,1,1,null,null,null,null,null,6,6,null,6,null,6,6,null,6,3,6,3,3,4,4,4,null,6,null,6,null,null,null,null,null,null,null,null,null,14,null,14,null,null,null,null,13,2,11,1,null,1,null,null,null,null,null,10,null,null,10,1,null,1,null,9,1,null,1,null,null,null,null,null,8,null,null,8,1,null,1,null,7,1,null,1,null,null,null,null,null,6,6,null,6,6,null,6,4,6,4,4,4,4,null,6,null,null,6,2,2,6,null,null,null,null,null,null,null,null,null,null,14,null,14,null,null,null,null,13,2,null,null,null,null,null,11,1,null,null,null,null,null,10,null,null,10,1,null,9,1,1,null,1,null,null,null,null,null,8,null,null,8,1,null,7,1,1,null,1,null,null,null,null,null,6,6,null,6,6,null,6,6,null,6,3,3,6,3,3,4,4,null,null,6,4,3,3,4,6,2,null,6,null,6,null,null,null,null,null,null,null,null,null,14,null,14,null,null,null,null,null,13,3,null,null,null,null,null,10,null,null,10,1,null,9,1,null,1,null,null,null,null,null,8,null,null,8,1,null,7,1,null,1,null,null,null,null,null,6,6,null,6,6,null,6,4,6,4,4,4,4,4,null,6,6,null,null,null,null,null,null,null,null,null,null,null,null,14,null,14,null,null,null,null,13,2,11,1,null,null,10,null,null,null,null,10,null,null,10,1,1,null,1,null,9,1,1,null,1,null,null,null,null,null,8,null,null,8,1,1,null,1,null,7,1,1,null,1,null,null,null,null,null,6,6,null,6,6,null,null,6,3,3,null,null,6,3,3,null,null,3,4,4,null,null,null,6,3,2,2,3,null,6,3,3,null,6,null,6,null,null,null,null,null,null,null,null,null,null,null,14,null,14,null,null,null,null,13,2,null,2,11,1,null,null,null,null,null,10,null,null,10,1,null,1,null,9,1,1,null,1,null,null,null,null,null,8,null,null,8,1,null,1,null,7,1,1,null,1,null,null,null,null,null,6,6,null,6,6,null,null,6,3,null,null,6,3,3,3,null,null,3,4,4,null,null,null,6,3,2,2,3,null,6,3,null,6,6,null,null,null,null,null,null,null,null,null,115,null,null,null,null,null,null,null,null,null,45,null,null,null,null,null,null,null,196,14,null,182,null,null,null,null,null,null,null,null,null,null,200,200,200,200,200,200,null,200,null,null,null,null,null,null]},{"name":"Icecave\/Collections\/Stack.php","source":"<?php\nnamespace Icecave\\Collections;\n\nuse Countable;\nuse Icecave\\Collections\\TypeCheck\\TypeCheck;\nuse Icecave\\Repr\\Repr;\nuse Serializable;\nuse SplStack;\n\n\/**\n * A last-in\/first-out (LIFO) stack of elements.\n *\/\nclass Stack implements QueuedAccessInterface, Countable, Serializable\n{\n    \/**\n     * @param mixed<mixed>|null $collection An iterable type containing the elements to include in this list, or null to create an empty list.\n     *\/\n    public function __construct($collection = null)\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n\n        $this->clear();\n\n        if (null !== $collection) {\n            foreach ($collection as $element) {\n                $this->push($element);\n            }\n        }\n    }\n\n    public function __clone()\n    {\n        $this->typeCheck->validateClone(func_get_args());\n\n        $this->elements = clone $this->elements;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of CollectionInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Fetch the number of elements in the collection.\n     *\n     * @see CollectionInterface::isEmpty()\n     *\n     * @return integer The number of elements in the collection.\n     *\/\n    public function size()\n    {\n        $this->typeCheck->size(func_get_args());\n\n        return $this->elements->count();\n    }\n\n    \/**\n     * Check if the collection is empty.\n     *\n     * @return boolean True if the collection is empty; otherwise, false.\n     *\/\n    public function isEmpty()\n    {\n        $this->typeCheck->isEmpty(func_get_args());\n\n        return $this->elements->isEmpty();\n    }\n\n    \/**\n     * Fetch a string representation of the collection.\n     *\n     * The string may not describe all elements of the collection, but should at least\n     * provide information on the type and state of the collection.\n     *\n     * @return string A string representation of the collection.\n     *\/\n    public function __toString()\n    {\n        if ($this->isEmpty()) {\n            return '<Stack 0>';\n        }\n\n        return sprintf(\n            '<Stack %d [next: %s]>',\n            $this->size(),\n            Repr::repr($this->next())\n        );\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of MutableCollectionInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Remove all elements from the collection.\n     *\/\n    public function clear()\n    {\n        $this->typeCheck->clear(func_get_args());\n\n        $this->elements = new SplStack;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of QueuedAccessInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Fetch the element at the top of the stack.\n     *\n     * @return mixed                              The element at the top of the stack.\n     * @throws Exception\\EmptyCollectionException if the collection is empty.\n     *\/\n    public function next()\n    {\n        $this->typeCheck->next(func_get_args());\n\n        if ($this->isEmpty()) {\n            throw new Exception\\EmptyCollectionException;\n        }\n\n        return $this->elements->top();\n    }\n\n    \/**\n     * Fetch the element at the top of the stack.\n     *\n     * @param mixed &$element Assigned the element at the top of the stack.\n     *\n     * @return boolean True is the element exists and was assigned to $element; otherwise, false.\n     *\/\n    public function tryNext(&$element)\n    {\n        $this->typeCheck->tryNext(func_get_args());\n\n        if ($this->isEmpty()) {\n            return false;\n        }\n\n        $element = $this->next();\n\n        return true;\n    }\n\n    \/**\n     * Add a new element to the end of the stack.\n     *\n     * @param mixed $element The element to add.\n     *\/\n    public function push($element)\n    {\n        $this->typeCheck->push(func_get_args());\n\n        $this->elements->push($element);\n    }\n\n    \/**\n     * Remove and return the element at the top of the stack.\n     *\n     * @return mixed                              The element at the top of the sequence.\n     * @throws Exception\\EmptyCollectionException if the collection is empty.\n     *\/\n    public function pop()\n    {\n        $this->typeCheck->pop(func_get_args());\n\n        if ($this->isEmpty()) {\n            throw new Exception\\EmptyCollectionException;\n        }\n\n        return $this->elements->pop();\n    }\n\n    \/**\n     * Remove the element at the top of the stack.\n     *\n     * @param mixed &$element Assigned the removed element.\n     *\n     * @return boolean True if the top element is removed and assigned to $element; otherwise, false.\n     *\/\n    public function tryPop(&$element = null)\n    {\n        $this->typeCheck->tryPop(func_get_args());\n\n        if ($this->isEmpty()) {\n            return false;\n        }\n\n        $element = $this->pop();\n\n        return true;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of Countable \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    public function count()\n    {\n        $this->typeCheck->count(func_get_args());\n\n        return $this->size();\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of Serializable \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Serialize the collection.\n     *\n     * @return string The serialized data.\n     *\/\n    public function serialize()\n    {\n        $this->typeCheck->serialize(func_get_args());\n\n        return serialize(\n            array_reverse(\n                iterator_to_array($this->elements)\n            )\n        );\n    }\n\n    \/**\n     * Unserialize collection data.\n     *\n     * @param string $packet The serialized data.\n     *\/\n    public function unserialize($packet)\n    {\n        TypeCheck::get(__CLASS__)->unserialize(func_get_args());\n\n        $elements = unserialize($packet);\n        $this->__construct($elements);\n    }\n\n    private $typeCheck;\n    private $elements;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,17,null,17,null,17,2,2,2,2,17,null,null,null,1,null,1,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,7,null,7,null,null,null,null,null,null,null,null,null,14,null,14,null,null,null,null,null,null,null,null,null,null,null,null,1,1,null,null,1,1,1,1,1,null,null,null,null,null,null,null,null,null,null,null,17,null,17,17,null,null,null,null,null,null,null,null,null,null,null,null,null,5,null,5,1,null,null,4,null,null,null,null,null,null,null,null,null,null,null,2,null,2,1,null,null,1,null,1,null,null,null,null,null,null,null,null,null,12,null,12,12,null,null,null,null,null,null,null,null,null,6,null,6,1,null,null,5,null,null,null,null,null,null,null,null,null,null,null,2,null,2,1,null,null,1,null,1,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,1,1,null,null,null,null,null,null,null,null,null,1,null,1,1,1,null,null,null,null]},{"name":"Icecave\/Collections\/Utility\/AssociativeKeyGenerator.php","source":"<?php\nnamespace Icecave\\Collections\\Utility;\n\nuse Icecave\\Collections\\TypeCheck\\TypeCheck;\n\n\/**\n * A basic associative key generator that allows for keys of any type.\n *\n * Given any value, generates a value suitable for use as an identifying key in a PHP array.\n *\/\nclass AssociativeKeyGenerator\n{\n    \/**\n     * @param callable $arrayHashFunction  The function to use for generating a hash of array keys and values.\n     * @param callable $objectHashFunction The function to use for generating a hash of objects.\n     *\/\n    public function __construct($arrayHashFunction = 'md5', $objectHashFunction = 'spl_object_hash')\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n\n        $this->arrayHashFunction = $arrayHashFunction;\n        $this->objectHashFunction = $objectHashFunction;\n    }\n\n    \/**\n     * Generate a suitable key value for use in a PHP array.\n     *\n     * @param mixed $value The value for which a key is required.\n     *\n     * @return int|string The key to use.\n     *\/\n    public function __invoke($value)\n    {\n        $this->typeCheck->validateInvoke(func_get_args());\n\n        return $this->generate($value);\n    }\n\n    \/**\n     * Generate a suitable key value for use in a PHP array.\n     *\n     * @param mixed $value The value for which a key is required.\n     *\n     * @return integer|string The key to use.\n     *\/\n    public function generate($value)\n    {\n        $this->typeCheck->generate(func_get_args());\n\n        switch (gettype($value)) {\n            case 'boolean':\n                return 'b' . ($value ? 't' : 'f');\n            case 'integer':\n                return $value;\n            case 'double':\n                return 'd' . $value;\n            case 'string':\n                return 's' . $value;\n            case 'resource':\n                return 'r' . intval($value);\n            case 'NULL':\n                return 'n';\n            case 'object':\n                return 'o' . call_user_func($this->objectHashFunction, $value);\n        }\n\n        return $this->generateForArray($value);\n    }\n\n    \/**\n     * Generate a suitable key value for use in a PHP array.\n     *\n     * @param array $value The value for which a key is required.\n     *\n     * @return integer|string The key to use.\n     *\/\n    protected function generateForArray(array $value)\n    {\n        $this->typeCheck->generateForArray(func_get_args());\n\n        if (empty($value)) {\n            return 'a';\n        }\n\n        $keyHashes = '';\n        $valueHashes = '';\n        $isAssociative = false;\n        $nextIndex = 0;\n\n        foreach ($value as $key => $value) {\n            $keyHashes .= $this->generate($key) . ',';\n            $valueHashes .= $this->generate($value) . ',';\n\n            if (!$isAssociative && $key !== $nextIndex++) {\n                $isAssociative = true;\n            }\n        }\n\n        if ($isAssociative) {\n            return 'a' . call_user_func($this->arrayHashFunction, $keyHashes . $valueHashes);\n        }\n\n        return 'v' . call_user_func($this->arrayHashFunction, $valueHashes);\n    }\n\n    private $typeCheck;\n    private $arrayHashFunction;\n    private $objectHashFunction;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,13,null,13,13,13,null,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,13,null,13,13,1,12,5,11,1,10,3,8,1,7,1,6,2,5,null,5,null,null,null,null,null,null,null,null,null,null,null,5,null,5,1,null,null,4,4,4,4,null,4,4,4,null,4,1,1,4,null,4,1,null,null,3,null,null,null,null,null,null]},{"name":"Icecave\/Collections\/Utility\/ObjectIdentityComparator.php","source":"<?php\nnamespace Icecave\\Collections\\Utility;\n\nuse Icecave\\Collections\\TypeCheck\\TypeCheck;\nuse Icecave\\Parity\\Comparator\\DeepComparator;\n\n\/**\n * A deep comparator with relaxed comparisons for objects.\n *\n * Objects are compared by identity, but otherwise behaves as a deep comparator.\n *\/\nclass ObjectIdentityComparator extends DeepComparator\n{\n    \/**\n     * @param object $lhs\n     * @param object $rhs\n     *\n     * @return integer The result of the comparison.\n     *\/\n    protected function compareObject($lhs, $rhs)\n    {\n        TypeCheck::get(__CLASS__)->compareObject(func_get_args());\n\n        if ($lhs === $rhs) {\n            return 0;\n        }\n\n        $diff = strcmp(get_class($lhs), get_class($rhs));\n        if ($diff !== 0) {\n            return $diff;\n        }\n\n        return strcmp(\n            spl_object_hash($lhs),\n            spl_object_hash($rhs)\n        );\n    }\n\n    \/**\n     * @param mixed $lhs\n     * @param mixed $rhs\n     *\n     * @return integer The result of the comparison.\n     *\/\n    public function __invoke($lhs, $rhs)\n    {\n        TypeCheck::get(__CLASS__)->validateInvoke(func_get_args());\n\n        return $this->compare($lhs, $rhs);\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,3,1,null,null,2,2,1,null,null,1,1,1,1,null,null,null,null,null,null,null,null,null,null,3,null,3,null,null]},{"name":"Icecave\/Collections\/Vector.php","source":"<?php\nnamespace Icecave\\Collections;\n\nuse ArrayAccess;\nuse Countable;\nuse Icecave\\Collections\\Iterator\\Traits;\nuse Icecave\\Collections\\TypeCheck\\TypeCheck;\nuse Iterator;\nuse SeekableIterator;\nuse Serializable;\nuse SplFixedArray;\n\n\/**\n * A mutable sequence with efficient access by position and iteration.\n *\/\nclass Vector implements MutableRandomAccessInterface, Countable, Iterator, SeekableIterator, ArrayAccess, Serializable\n{\n    \/**\n     * @param mixed<mixed>|null $collection An iterable type containing the elements to include in this vector, or null to create an empty vector.\n     *\/\n    public function __construct($collection = null)\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n\n        if (is_array($collection)) {\n            $this->elements = SplFixedArray::fromArray($collection, false);\n            $this->size = count($collection);\n        } else {\n            $this->clear();\n            if (null !== $collection) {\n                $this->insertMany(0, $collection);\n            }\n        }\n    }\n\n    public function __clone()\n    {\n        $this->typeCheck->validateClone(func_get_args());\n\n        $this->elements = clone $this->elements;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of CollectionInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Fetch the number of elements in the collection.\n     *\n     * @see CollectionInterface::isEmpty()\n     *\n     * @return integer The number of elements in the collection.\n     *\/\n    public function size()\n    {\n        $this->typeCheck->size(func_get_args());\n\n        return $this->size;\n    }\n\n    \/**\n     * Check if the collection is empty.\n     *\n     * @return boolean True if the collection is empty; otherwise, false.\n     *\/\n    public function isEmpty()\n    {\n        $this->typeCheck->isEmpty(func_get_args());\n\n        return 0 === $this->size;\n    }\n\n    \/**\n     * Fetch a string representation of the collection.\n     *\n     * The string may not describe all elements of the collection, but should at least\n     * provide information on the type and state of the collection.\n     *\n     * @return string A string representation of the collection.\n     *\/\n    public function __toString()\n    {\n        if ($this->isEmpty()) {\n            return '<Vector 0>';\n        }\n\n        $elements = $this\n            ->slice(0, 3)\n            ->map('Icecave\\Repr\\Repr::repr');\n\n        if ($this->size > 3) {\n            $format = '<Vector %d [%s, ...]>';\n        } else {\n            $format = '<Vector %d [%s]>';\n        }\n\n        return sprintf(\n            $format,\n            $this->size,\n            implode(', ', $elements->elements())\n        );\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of MutableCollectionInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Remove all elements from the collection.\n     *\/\n    public function clear()\n    {\n        $this->typeCheck->clear(func_get_args());\n\n        $this->elements = new SplFixedArray;\n        $this->size = 0;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of IteratorTraitsProvider \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Return traits describing the collection's iteration capabilities.\n     *\n     * @return Traits\n     *\/\n    public function iteratorTraits()\n    {\n        $this->typeCheck->iteratorTraits(func_get_args());\n\n        return new Traits(true, true);\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of IterableInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Fetch a native array containing the elements in the collection.\n     *\n     * @return array An array containing the elements in the collection.\n     *\/\n    public function elements()\n    {\n        $this->typeCheck->elements(func_get_args());\n\n        $elements = array();\n        foreach ($this->elements as $index => $element) {\n            if ($index >= $this->size) {\n                break;\n            } else {\n                $elements[] = $element;\n            }\n        }\n\n        return $elements;\n    }\n\n    \/**\n     * Check if the collection contains an element.\n     *\n     * @param mixed $element The element to check.\n     *\n     * @return boolean True if the collection contains $element; otherwise, false.\n     *\/\n    public function contains($element)\n    {\n        $this->typeCheck->contains(func_get_args());\n\n        return null !== $this->indexOf($element);\n    }\n\n    \/**\n     * Fetch a new collection with a subset of the elements from this collection.\n     *\n     * @param callable|null $predicate A predicate function used to determine which elements to include, or null to include all non-null elements.\n     *\n     * @return Vector The filtered collection.\n     *\/\n    public function filter($predicate = null)\n    {\n        $this->typeCheck->filter(func_get_args());\n\n        if (null === $predicate) {\n            $predicate = function ($element) {\n                return null !== $element;\n            };\n        }\n\n        $result = new static;\n        $result->reserve($this->size);\n\n        foreach ($this->elements as $index => $element) {\n            if ($index >= $this->size) {\n                break;\n            } elseif (call_user_func($predicate, $element)) {\n                $result->pushBack($element);\n            }\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Produce a new collection by applying a transformation to each element.\n     *\n     * The new elements produced by the transform need not be of the same type.\n     * It is not guaranteed that the concrete type of the resulting collection will match this collection.\n     *\n     * @param callable $transform The transform to apply to each element.\n     *\n     * @return IterableInterface A new collection produced by applying $transform to each element in this collection.\n     *\/\n    public function map($transform)\n    {\n        $this->typeCheck->map(func_get_args());\n\n        $result = new static;\n        $result->resize($this->size);\n\n        foreach ($this->elements as $index => $element) {\n            if ($index >= $this->size) {\n                break;\n            } else {\n                $result->elements[$index] = call_user_func($transform, $element);\n            }\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Partitions this collection into two collections according to a predicate.\n     *\n     * It is not guaranteed that the concrete type of the partitioned collections will match this collection.\n     *\n     * @param callable $predicate A predicate function used to determine which partitioned collection to place the elements in.\n     *\n     * @return tuple<IterableInterface,IterableInterface> A 2-tuple containing the partitioned collections. The first collection contains the element for which the predicate returned true.\n     *\/\n    public function partition($predicate)\n    {\n        $this->typeCheck->partition(func_get_args());\n\n        $left = new static;\n        $right = new static;\n\n        foreach ($this->elements as $index => $element) {\n            if ($index >= $this->size) {\n                break;\n            } elseif (call_user_func($predicate, $element)) {\n                $left->pushBack($element);\n            } else {\n                $right->pushBack($element);\n            }\n        }\n\n        return array($left, $right);\n    }\n\n    \/**\n     * Invokes the given callback on every element in the collection.\n     *\n     * This method behaves the same as {@see IterableInterface::map()} except that the return value of the callback is not retained.\n     *\n     * @param callable $callback The callback to invoke with each element.\n     *\/\n    public function each($callback)\n    {\n        $this->typeCheck->each(func_get_args());\n\n        foreach ($this->elements as $index => $element) {\n            if ($index >= $this->size) {\n                break;\n            } else {\n                call_user_func($callback, $element);\n            }\n        }\n    }\n\n    \/**\n     * Returns true if the given predicate returns true for all elements.\n     *\n     * The loop is short-circuited, exiting after the first element for which the predicate returns false.\n     *\n     * @param callable $predicate\n     *\n     * @return boolean True if $predicate($element) returns true for all elements; otherwise, false.\n     *\/\n    public function all($predicate)\n    {\n        $this->typeCheck->all(func_get_args());\n\n        foreach ($this->elements as $index => $element) {\n            if ($index >= $this->size) {\n                break;\n            } elseif (!call_user_func($predicate, $element)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \/**\n     * Returns true if the given predicate returns true for any element.\n     *\n     * The loop is short-circuited, exiting after the first element for which the predicate returns false.\n     *\n     * @param callable $predicate\n     *\n     * @return boolean True if $predicate($element) returns true for any element; otherwise, false.\n     *\/\n    public function any($predicate)\n    {\n        $this->typeCheck->any(func_get_args());\n\n        foreach ($this->elements as $index => $element) {\n            if ($index >= $this->size) {\n                break;\n            } elseif (call_user_func($predicate, $element)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of MutableIterableInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Filter this collection in-place.\n     *\n     * @param callable|null $predicate A predicate function used to determine which elements to retain, or null to retain all non-null elements.\n     *\/\n    public function filterInPlace($predicate = null)\n    {\n        $this->typeCheck->filterInPlace(func_get_args());\n\n        if (null === $predicate) {\n            $predicate = function ($element) {\n                return null !== $element;\n            };\n        }\n\n        $size = $this->size;\n        $this->size = 0;\n\n        foreach ($this->elements as $index => $element) {\n            if (call_user_func($predicate, $element)) {\n                $this->elements[$this->size++] = $element;\n            }\n\n            if ($index >= $this->size) {\n                $this->elements[$index] = null;\n            }\n        }\n    }\n\n    \/**\n     * Replace each element in the collection with the result of a transformation on that element.\n     *\n     * The new elements produced by the transform must be the same type.\n     *\n     * @param callable $transform The transform to apply to each element.\n     *\/\n    public function mapInPlace($transform)\n    {\n        $this->typeCheck->mapInPlace(func_get_args());\n\n        foreach ($this->elements as $index => $element) {\n            if ($index >= $this->size) {\n                break;\n            } else {\n                $this->elements[$index] = call_user_func($transform, $element);\n            }\n        }\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of SequenceInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Fetch the first element in the sequence.\n     *\n     * @return mixed                              The first element in the sequence.\n     * @throws Exception\\EmptyCollectionException if the collection is empty.\n     *\/\n    public function front()\n    {\n        $this->typeCheck->front(func_get_args());\n\n        if ($this->isEmpty()) {\n            throw new Exception\\EmptyCollectionException;\n        }\n\n        return $this->elements[0];\n    }\n\n    \/**\n     * Fetch the first element in the sequence.\n     *\n     * @param mixed &$element Assigned the element at the front of collection.\n     *\n     * @return boolean True is the element exists and was assigned to $element; otherwise, false.\n     *\/\n    public function tryFront(&$element)\n    {\n        $this->typeCheck->tryFront(func_get_args());\n\n        if ($this->isEmpty()) {\n            return false;\n        }\n        $element = $this->front();\n\n        return true;\n    }\n\n    \/**\n     * Fetch the last element in the sequence.\n     *\n     * @return mixed                              The first element in the sequence.\n     * @throws Exception\\EmptyCollectionException if the collection is empty.\n     *\/\n    public function back()\n    {\n        $this->typeCheck->back(func_get_args());\n\n        if ($this->isEmpty()) {\n            throw new Exception\\EmptyCollectionException;\n        }\n\n        return $this->elements[$this->size - 1];\n    }\n\n    \/**\n     * Fetch the last element in the sequence.\n     *\n     * @param mixed &$element Assigned the element at the front of collection.\n     *\n     * @return boolean True is the element exists and was assigned to $element; otherwise, false.\n     *\/\n    public function tryBack(&$element)\n    {\n        $this->typeCheck->tryBack(func_get_args());\n\n        if ($this->isEmpty()) {\n            return false;\n        }\n        $element = $this->back();\n\n        return true;\n    }\n\n    \/**\n     * Create a new sequence with the elements from this sequence in sorted order.\n     *\n     * @param callable|null $comparator A strcmp style comparator function.\n     *\n     * @return Vector\n     *\/\n    public function sort($comparator = null)\n    {\n        $this->typeCheck->sort(func_get_args());\n\n        $elements = $this->elements();\n\n        if (null === $comparator) {\n            sort($elements);\n        } else {\n            usort($elements, $comparator);\n        }\n\n        return new static($elements);\n    }\n\n    \/**\n     * Create a new sequence with the elements from this sequence in reverse order.\n     *\n     * It is not guaranteed that the concrete type of the reversed collection will match this collection.\n     *\n     * @return Vector The reversed sequence.\n     *\/\n    public function reverse()\n    {\n        $this->typeCheck->reverse(func_get_args());\n\n        $result = new static;\n        $result->resize($this->size);\n\n        $target = $this->size - 1;\n        foreach ($this->elements as $index => $element) {\n            if ($index >= $this->size) {\n                break;\n            } else {\n                $result->elements[$target--] = $element;\n            }\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Create a new sequence by appending the elements in the given sequence to this sequence.\n     *\n     * @param mixed<mixed> $sequence       The sequence to append.\n     * @param mixed<mixed> $additional,... Additional sequences to append.\n     *\n     * @return SequenceInterface A new sequence containing all elements from this sequence and $sequence.\n     *\/\n    public function join($sequence)\n    {\n        $this->typeCheck->join(func_get_args());\n\n        $result = new static($this);\n        foreach (func_get_args() as $sequence) {\n            $result->insertMany($result->size(), $sequence);\n        }\n\n        return $result;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of MutableSequenceInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Sort this sequence in-place.\n     *\n     * @param callable|null $comparator A strcmp style comparator function.\n     *\/\n    public function sortInPlace($comparator = null)\n    {\n        $this->typeCheck->sortInPlace(func_get_args());\n\n        $elements = $this->elements();\n\n        if (null === $comparator) {\n            sort($elements);\n        } else {\n            usort($elements, $comparator);\n        }\n\n        $this->elements = SplFixedArray::fromArray($elements);\n    }\n\n    \/**\n     * Reverse this sequence in-place.\n     *\/\n    public function reverseInPlace()\n    {\n        $this->typeCheck->reverseInPlace(func_get_args());\n\n        $first = 0;\n        $last  = $this->size;\n\n        while (($first !== $last) && ($first !== --$last)) {\n            $this->swap($first++, $last);\n        }\n    }\n\n    \/**\n     * Appending elements in the given sequence to this sequence.\n     *\n     * @param mixed<mixed> $sequence       The sequence to append.\n     * @param mixed<mixed> $additional,... Additional sequences to append.\n     *\/\n    public function append($sequence)\n    {\n        $this->typeCheck->append(func_get_args());\n\n        foreach (func_get_args() as $sequence) {\n            $this->insertMany($this->size, $sequence);\n        }\n    }\n\n    \/**\n     * Add a new element to the front of the sequence.\n     *\n     * @param mixed $element The element to prepend.\n     *\/\n    public function pushFront($element)\n    {\n        $this->typeCheck->pushFront(func_get_args());\n\n        $this->shiftRight(0, 1);\n        $this->elements[0] = $element;\n        ++$this->size;\n    }\n\n    \/**\n     * Remove and return the element at the front of the sequence.\n     *\n     * @return mixed                              The element at the front of the sequence.\n     * @throws Exception\\EmptyCollectionException if the collection is empty.\n     *\/\n    public function popFront()\n    {\n        $this->typeCheck->popFront(func_get_args());\n\n        $element = $this->front();\n        $this->shiftLeft(1, 1);\n        --$this->size;\n\n        return $element;\n    }\n\n    \/**\n     * Remove the element at the front of the sequence.\n     *\n     * @param mixed &$element Assigned the removed element.\n     *\n     * @return boolean True if the front element is removed and assigned to $element; otherwise, false.\n     *\/\n    public function tryPopFront(&$element = null)\n    {\n        $this->typeCheck->tryPopFront(func_get_args());\n\n        if ($this->isEmpty()) {\n            return false;\n        }\n        $element = $this->popFront();\n\n        return true;\n    }\n\n    \/**\n     * Add a new element to the back of the sequence.\n     *\n     * @param mixed $element The element to append.\n     *\/\n    public function pushBack($element)\n    {\n        $this->typeCheck->pushBack(func_get_args());\n\n        $this->expand(1);\n        $this->elements[$this->size++] = $element;\n    }\n\n    \/**\n     * Remove and return the element at the back of the sequence.\n     *\n     * @return mixed                              The element at the back of the sequence.\n     * @throws Exception\\EmptyCollectionException if the collection is empty.\n     *\/\n    public function popBack()\n    {\n        $this->typeCheck->popBack(func_get_args());\n\n        $element = $this->back();\n        $this->elements[--$this->size] = null;\n\n        return $element;\n    }\n\n    \/**\n     * Remove the element at the back of the sequence.\n     *\n     * @param mixed &$element Assigned the removed element.\n     *\n     * @return boolean True if the back element is removed and assigned to $element; otherwise, false.\n     *\/\n    public function tryPopBack(&$element = null)\n    {\n        $this->typeCheck->tryPopBack(func_get_args());\n\n        if ($this->isEmpty()) {\n            return false;\n        }\n        $element = $this->popBack();\n\n        return true;\n    }\n\n    \/**\n     * Resize the sequence.\n     *\n     * @param integer $size    The new size of the collection.\n     * @param mixed   $element The value to use for populating new elements when $size > $this->size().\n     *\/\n    public function resize($size, $element = null)\n    {\n        $this->typeCheck->resize(func_get_args());\n\n        if ($this->size > $size) {\n            $this->elements->setSize($size);\n            $this->size = $size;\n        } elseif (null === $element) {\n            $this->reserve($size);\n            $this->size = $size;\n        } else {\n            $this->reserve($size);\n            while ($this->size < $size) {\n                $this->elements[$this->size++] = $element;\n            }\n        }\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of RandomAccessInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Fetch the element at the given index.\n     *\n     * @param mixed $index The index of the element to fetch, if index is a negative number the element that far from the end of the sequence is returned.\n     *\n     * @return mixed                    The element at $index.\n     * @throws Exception\\IndexException if $index is out of range.\n     *\/\n    public function get($index)\n    {\n        $this->typeCheck->get(func_get_args());\n\n        $this->validateIndex($index);\n\n        return $this->elements[$index];\n    }\n\n    \/**\n     * Extract a range of elements.\n     *\n     * It is not guaranteed that the concrete type of the slice collection will match this collection.\n     *\n     * @param integer      $index The index from which the slice will start. If index is a negative number the slice will begin that far from the end of the sequence.\n     * @param integer|null $count The maximum number of elements to include in the slice, or null to include all elements from $index to the end of the sequence.\n     *\n     * @return SequenceInterface        The sliced sequence.\n     * @throws Exception\\IndexException if $index is out of range.\n     *\/\n    public function slice($index, $count = null)\n    {\n        $this->typeCheck->slice(func_get_args());\n\n        $this->validateIndex($index);\n\n        if (null === $count) {\n            $end = $this->size;\n        } else {\n            $end = $this->clamp(\n                $index + $count,\n                $index,\n                $this->size\n            );\n        }\n\n        return $this->range($index, $end);\n    }\n\n    \/**\n     * Extract a range of elements.\n     *\n     * It is not guaranteed that the concrete type of the slice collection will match this collection.\n     *\n     * Extracts all elements in the range [$begin, $end), i.e. $begin is inclusive, $end is exclusive.\n     *\n     * @param integer $begin The index from which the slice will start. If begin is a negative number the slice will begin that far from the end of the sequence.\n     * @param integer $end   The index at which the slice will end. If end is a negative number the slice will end that far from the end of the sequence.\n     *\n     * @return SequenceInterface        The sliced sequence.\n     * @throws Exception\\IndexException if $begin or $end is out of range.\n     *\/\n    public function range($begin, $end)\n    {\n        $this->typeCheck->range(func_get_args());\n\n        $this->validateIndex($begin);\n        $this->validateIndex($end, $this->size);\n\n        $result = new static;\n\n        if ($begin < $end) {\n            $result->resize($end - $begin);\n\n            $index = 0;\n            while ($index < $result->size()) {\n                $result->elements[$index++] = $this->elements[$begin++];\n            }\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Find the index of the first instance of a particular element in the sequence.\n     *\n     * @param mixed   $element    The element to search for.\n     * @param integer $startIndex The index to start searching from.\n     *\n     * @return integer|null             The index of the element, or null if is not present in the sequence.\n     * @throws Exception\\IndexException if $startIndex is out of range.\n     *\/\n    public function indexOf($element, $startIndex = 0)\n    {\n        $this->typeCheck->indexOf(func_get_args());\n\n        $predicate = function ($e) use ($element) {\n            return $element === $e;\n        };\n\n        return $this->find($predicate, $startIndex);\n    }\n\n    \/**\n     * Find the index of the last instance of a particular element in the sequence.\n     *\n     * @param mixed        $element    The element to search for.\n     * @param integer|null $startIndex The index to start searching from, or null to use the last index.\n     *\n     * @return integer|null             The index of the element, or null if is not present in the sequence.\n     * @throws Exception\\IndexException if $startIndex is out of range.\n     *\/\n    public function indexOfLast($element, $startIndex = null)\n    {\n        $this->typeCheck->indexOfLast(func_get_args());\n\n        $predicate = function ($e) use ($element) {\n            return $element === $e;\n        };\n\n        return $this->findLast($predicate, $startIndex);\n    }\n\n    \/**\n     * Find the index of the first instance of an element matching given criteria.\n     *\n     * @param callable $predicate  A predicate function used to determine which element constitutes a match.\n     * @param integer  $startIndex The index to start searching from.\n     *\n     * @return integer|null             The index of the element, or null if is not present in the sequence.\n     * @throws Exception\\IndexException if $startIndex is out of range.\n     *\/\n    public function find($predicate, $startIndex = 0)\n    {\n        $this->typeCheck->find(func_get_args());\n\n        if ($this->isEmpty()) {\n            return null;\n        }\n\n        $this->validateIndex($startIndex);\n\n        for ($index = $startIndex; $index < $this->size; ++$index) {\n            if (call_user_func($predicate, $this->elements[$index])) {\n                return $index;\n            }\n        }\n\n        return null;\n    }\n\n    \/**\n     * Find the index of the last instance of an element matching given criteria.\n     *\n     * @param callable     $predicate  A predicate function used to determine which element constitutes a match.\n     * @param integer|null $startIndex The index to start searching from, or null to use the last index.\n     *\n     * @return integer|null             The index of the element, or null if is not present in the sequence.\n     * @throws Exception\\IndexException if $startIndex is out of range.\n     *\/\n    public function findLast($predicate, $startIndex = null)\n    {\n        $this->typeCheck->findLast(func_get_args());\n\n        if ($this->isEmpty()) {\n            return null;\n        } elseif (null === $startIndex) {\n            $startIndex = $this->size - 1;\n        }\n\n        for ($index = $startIndex; $index >= 0; --$index) {\n            if (call_user_func($predicate, $this->elements[$index])) {\n                return $index;\n            }\n        }\n\n        return null;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of MutableRandomAccessInterface \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Replace the element at a particular position in the sequence.\n     *\n     * @param integer $index   The index of the element to set, if index is a negative number the element that far from the end of the sequence is set.\n     * @param mixed   $element The element to set.\n     *\n     * @throws Exception\\IndexException if $index is out of range.\n     *\/\n    public function set($index, $element)\n    {\n        $this->typeCheck->set(func_get_args());\n\n        $this->validateIndex($index);\n        $this->elements[$index] = $element;\n    }\n\n    \/**\n     * Insert an element at a particular index.\n     *\n     * @param integer $index   The index at which the element is inserted, if index is a negative number the element is inserted that far from the end of the sequence.\n     * @param mixed   $element The element to insert.\n     *\n     * @throws Exception\\IndexException if $index is out of range.\n     *\/\n    public function insert($index, $element)\n    {\n        $this->typeCheck->insert(func_get_args());\n\n        $this->insertMany($index, array($element));\n    }\n\n    \/**\n     * Insert a range of elements at a particular index.\n     *\n     * @param integer      $index    The index at which the elements are inserted, if index is a negative number the elements are inserted that far from the end of the sequence.\n     * @param mixed<mixed> $elements The elements to insert.\n     *\/\n    public function insertMany($index, $elements)\n    {\n        $this->typeCheck->insertMany(func_get_args());\n\n        $this->validateIndex($index, $this->size);\n\n        \/\/ The number of elements is not known.\n        \/\/ Using the normal expansion rules we create a gap in which to insert the elements.\n        \/\/ Once all elements have been inserted the gap is closed.\n        if (!Collection::iteratorTraits($elements)->isCountable) {\n            $shiftIndex = $index;\n\n            foreach ($elements as $element) {\n                if ($index === $shiftIndex) {\n                    $actualExpansion = $this->expand(1);\n                    $this->shiftRight($index, $actualExpansion);\n                    $shiftIndex += $actualExpansion;\n                }\n\n                $this->elements[$index++] = $element;\n                ++$this->size;\n            }\n\n            $this->shiftLeft($shiftIndex, $shiftIndex - $index);\n\n        \/\/ The number of elements is known, expand the vector once and insert the elements.\n        } elseif ($count = count($elements)) {\n            $this->shiftRight($index, $count);\n            $this->size += $count;\n\n            foreach ($elements as $element) {\n                $this->elements[$index++] = $element;\n            }\n        }\n    }\n\n    \/**\n     * Remove the element at a given index.\n     *\n     * Elements after the given endex are moved forward by one.\n     *\n     * @param integer $index The index of the element to remove, if index is a negative number the element that far from the end of the sequence is removed.\n     *\n     * @throws Exception\\IndexException if $index is out of range.\n     *\/\n    public function remove($index)\n    {\n        $this->typeCheck->remove(func_get_args());\n\n        $this->removeRange($index, $index + 1);\n    }\n\n    \/**\n     * Remove a range of elements at a given index.\n     *\n     * @param integer      $index The index of the first element to remove, if index is a negative number the removal begins that far from the end of the sequence.\n     * @param integer|null $count The number of elements to remove, or null to remove all elements up to the end of the sequence.\n     *\n     * @throws Exception\\IndexException if $index is out of range.\n     *\/\n    public function removeMany($index, $count = null)\n    {\n        $this->typeCheck->removeMany(func_get_args());\n\n        $this->validateIndex($index);\n\n        $count = $this->clamp($count, 0, $this->size - $index);\n        $this->shiftLeft($index + $count, $count);\n        $this->size -= $count;\n    }\n\n    \/**\n     * Remove a range of elements at a given index.\n     *\n     * Removes all elements in the range [$begin, $end), i.e. $begin is inclusive, $end is exclusive.\n     *\n     * @param integer $begin The index of the first element to remove, if $begin is a negative number the removal begins that far from the end of the sequence.\n     * @param integer $end   The index of the last element to remove, if $end is a negative number the removal ends that far from the end of the sequence.\n     *\n     * @throws Exception\\IndexException if $begin or $end is out of range.\n     *\/\n    public function removeRange($begin, $end)\n    {\n        $this->typeCheck->removeRange(func_get_args());\n\n        $this->validateIndex($begin);\n        $this->validateIndex($end, $this->size);\n        $this->removeMany($begin, $end - $begin);\n    }\n\n    \/**\n     * Replace a range of elements with a second set of elements.\n     *\n     * Replaces all elements in the range [$begin, $end), i.e. $begin is inclusive, $end is exclusive.\n     *\n     * @param integer      $index    The index of the first element to replace, if index is a negative number the replace begins that far from the end of the sequence.\n     * @param mixed<mixed> $elements The elements to insert.\n     * @param integer|null $count    The number of elements to replace, or null to replace all elements up to the end of the sequence.\n     *\/\n    public function replace($index, $elements, $count = null)\n    {\n        $this->typeCheck->replace(func_get_args());\n\n        $this->validateIndex($index);\n\n        $count = $this->clamp($count, 0, $this->size - $index);\n\n        \/\/ Element count is available ...\n        if (Collection::iteratorTraits($elements)->isCountable) {\n            $diff = count($elements) - $count;\n\n            if ($diff > 0) {\n                $this->shiftRight($index + $count, $diff);\n            } elseif ($diff < 0) {\n                $this->shiftLeft($index + $count, abs($diff));\n            }\n\n            $this->size += $diff;\n\n            foreach ($elements as $element) {\n                $this->elements[$index++] = $element;\n            }\n\n        \/\/ No count is available ...\n        } else {\n            $originalSize = $this->size;\n            $this->insertMany($index, $elements);\n            $elementCount = $this->size - $originalSize;\n            $this->removeMany($index + $elementCount, $count);\n        }\n    }\n\n    \/**\n     * Replace a range of elements with a second set of elements.\n     *\n     * @param integer      $begin    The index of the first element to replace, if begin is a negative number the replace begins that far from the end of the sequence.\n     * @param integer      $end      The index of the last element to replace, if end is a negativ enumber the replace ends that far from the end of the sequence.\n     * @param mixed<mixed> $elements The elements to insert.\n     *\/\n    public function replaceRange($begin, $end, $elements)\n    {\n        $this->typeCheck->replaceRange(func_get_args());\n\n        $this->validateIndex($begin);\n        $this->validateIndex($end, $this->size);\n        $this->replace($begin, $elements, $end - $begin);\n    }\n\n    \/**\n     * Swap the elements at two index positions.\n     *\n     * @param integer $index1 The index of the first element.\n     * @param integer $index2 The index of the second element.\n     *\n     * @throws Exception\\IndexException if $index1 or $index2 is out of range.\n     *\/\n    public function swap($index1, $index2)\n    {\n        $this->typeCheck->swap(func_get_args());\n\n        $this->validateIndex($index1);\n        $this->validateIndex($index2);\n\n        $temp = $this->elements[$index1];\n        $this->elements[$index1] = $this->elements[$index2];\n        $this->elements[$index2] = $temp;\n    }\n\n    \/**\n     * Swap the elements at two index positions.\n     *\n     * @param integer $index1 The index of the first element.\n     * @param integer $index2 The index of the second element.\n     *\n     * @return boolean True if $index1 and $index2 are in range and the swap is successful.\n     *\/\n    public function trySwap($index1, $index2)\n    {\n        $this->typeCheck->trySwap(func_get_args());\n\n        if ($index1 < 0) {\n            $index1 += $this->size;\n        }\n\n        if ($index2 < 0) {\n            $index2 += $this->size;\n        }\n\n        if ($index1 < 0 || $index1 >= $this->size) {\n            return false;\n        }\n\n        if ($index2 < 0 || $index2 >= $this->size) {\n            return false;\n        }\n\n        $temp = $this->elements[$index1];\n        $this->elements[$index1] = $this->elements[$index2];\n        $this->elements[$index2] = $temp;\n\n        return true;\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of Countable \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    public function count()\n    {\n        $this->typeCheck->count(func_get_args());\n\n        return $this->size();\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of Iterator \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    public function current()\n    {\n        $this->typeCheck->current(func_get_args());\n\n        return current($this->elements);\n    }\n\n    public function key()\n    {\n        $this->typeCheck->key(func_get_args());\n\n        return key($this->elements);\n    }\n\n    public function next()\n    {\n        $this->typeCheck->next(func_get_args());\n\n        next($this->elements);\n    }\n\n    public function rewind()\n    {\n        $this->typeCheck->rewind(func_get_args());\n\n        reset($this->elements);\n    }\n\n    public function valid()\n    {\n        $this->typeCheck->valid(func_get_args());\n\n        $index = $this->key();\n\n        return null !== $index\n            && $index < $this->size();\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of SeekableIterator \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * @param integer $index\n     *\/\n    public function seek($index)\n    {\n        $this->typeCheck->seek(func_get_args());\n\n        $this->validateIndex($index);\n\n        $currentIndex = $this->key();\n\n        if ($index < $currentIndex) {\n            $this->rewind();\n        } else {\n            $index -= $currentIndex;\n        }\n\n        while ($index--) {\n            $this->next();\n        }\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of ArrayAccess \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * @param mixed $offset\n     *\n     * @return boolean True if offset is a valid, in-range index for this vector; otherwise, false.\n     *\/\n    public function offsetExists($offset)\n    {\n        $this->typeCheck->offsetExists(func_get_args());\n\n        return is_integer($offset)\n            && $offset >= 0\n            && $offset < $this->size();\n    }\n\n    \/**\n     * @param integer $offset\n     *\n     * @return mixed The element at the index specified by $offset.\n     *\/\n    public function offsetGet($offset)\n    {\n        $this->typeCheck->offsetGet(func_get_args());\n\n        return $this->get($offset);\n    }\n\n    \/**\n     * @param integer|null $offset\n     * @param mixed        $value\n     *\/\n    public function offsetSet($offset, $value)\n    {\n        $this->typeCheck->offsetSet(func_get_args());\n\n        if (null === $offset) {\n            $this->pushBack($value);\n        } else {\n            $this->set($offset, $value);\n        }\n    }\n\n    \/**\n     * @param integer $offset\n     *\/\n    public function offsetUnset($offset)\n    {\n        $this->typeCheck->offsetUnset(func_get_args());\n\n        if ($this->offsetExists($offset)) {\n            $this->remove($offset);\n        }\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Implementation of Serializable \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Serialize the collection.\n     *\n     * @return string The serialized data.\n     *\/\n    public function serialize()\n    {\n        $this->typeCheck->serialize(func_get_args());\n\n        return serialize($this->elements());\n    }\n\n    \/**\n     * Unserialize collection data.\n     *\n     * @param string $packet The serialized data.\n     *\/\n    public function unserialize($packet)\n    {\n        TypeCheck::get(__CLASS__)->unserialize(func_get_args());\n\n        $elements = unserialize($packet);\n        $this->__construct($elements);\n    }\n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Model specific methods \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    \/**\n     * Fetch the current reserved capacity of the vector.\n     *\n     * @return integer The current reserved capacity of the vector.\n     *\/\n    public function capacity()\n    {\n        $this->typeCheck->capacity(func_get_args());\n\n        return $this->elements->count();\n    }\n\n    \/**\n     * Reserve enough memory to hold at least $size elements.\n     *\n     * @param integer $size\n     *\/\n    public function reserve($size)\n    {\n        $this->typeCheck->reserve(func_get_args());\n\n        if ($size > $this->capacity()) {\n            $this->elements->setSize($size);\n        }\n    }\n\n    \/**\n     * Shrink the reserved memory to match the current vector size.\n     *\/\n    public function shrink()\n    {\n        $this->typeCheck->shrink(func_get_args());\n\n        $this->elements->setSize($this->size);\n    }\n\n    \/**\n     * @param integer      &$index\n     * @param integer|null $max\n     *\/\n    private function validateIndex(&$index, $max = null)\n    {\n        if (null === $max) {\n            $max = $this->size - 1;\n        }\n\n        if ($index < 0) {\n            $index += $this->size;\n        }\n\n        if ($index < 0 || $index > $max) {\n            throw new Exception\\IndexException($index);\n        }\n    }\n\n    \/**\n     * @param integer $index\n     * @param integer $count\n     *\/\n    private function shiftLeft($index, $count)\n    {\n        $capacity = $this->capacity();\n        $target = $index - $count;\n        $source = $index;\n\n        while ($source < $capacity) {\n            $this->elements[$target++] = $this->elements[$source++];\n        }\n\n        while ($target < $capacity) {\n            $this->elements[$target++] = null;\n        }\n    }\n\n    \/**\n     * @param integer $index\n     * @param integer $count\n     *\/\n    private function shiftRight($index, $count)\n    {\n        $this->expand($count);\n\n        $source = $this->size - 1;\n        $target = $source + $count;\n\n        while ($source >= $index) {\n            $this->elements[$target--] = $this->elements[$source--];\n        }\n    }\n\n    \/**\n     * @param integer|null $value\n     * @param integer      $min\n     * @param integer      $max\n     *\/\n    private function clamp($value, $min, $max)\n    {\n        if (null === $value) {\n            return $max;\n        } elseif ($value > $max) {\n            return $max;\n        } elseif ($value < $min) {\n            return $min;\n        } else {\n            return $value;\n        }\n    }\n\n    \/**\n     * @param integer $count\n     *\n     * @return integer The unused capacity of the vector.\n     *\/\n    private function expand($count)\n    {\n        $currentCapacity = $this->capacity();\n        $targetCapacity  = $this->size + $count;\n\n        if (0 === $currentCapacity) {\n            $newCapacity = $targetCapacity;\n        } else {\n            $newCapacity = $currentCapacity;\n            while ($newCapacity < $targetCapacity) {\n                $newCapacity <<= 1;\n            }\n        }\n\n        $this->reserve($newCapacity);\n\n        return $this->capacity() - $this->size;\n    }\n\n    private $typeCheck;\n    private $elements;\n    private $size;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,144,null,144,4,4,4,144,144,2,2,null,144,null,null,null,1,null,1,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,144,null,144,null,null,null,null,null,null,null,null,null,29,null,29,null,null,null,null,null,null,null,null,null,null,null,null,1,1,null,null,1,1,1,null,1,1,1,1,null,null,1,1,1,1,1,null,null,null,null,null,null,null,null,null,null,null,144,null,144,144,144,null,null,null,null,null,null,null,null,null,null,null,null,3,null,3,null,null,null,null,null,null,null,null,null,null,null,null,null,85,null,85,85,82,40,null,82,null,85,null,85,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,2,null,2,1,1,1,1,null,2,2,null,2,2,1,2,2,2,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,2,null,2,2,1,null,2,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,null,1,1,1,1,1,1,1,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,null,1,null,1,1,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,1,1,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,1,1,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,3,1,1,1,1,null,3,3,null,3,3,3,3,null,3,3,3,3,3,null,null,null,null,null,null,null,null,null,null,1,null,1,1,1,null,1,null,1,1,null,null,null,null,null,null,null,null,null,null,null,null,null,6,null,6,2,null,null,4,null,null,null,null,null,null,null,null,null,null,null,2,null,2,1,null,1,null,1,null,null,null,null,null,null,null,null,null,null,7,null,7,2,null,null,5,null,null,null,null,null,null,null,null,null,null,null,2,null,2,1,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,2,1,1,1,null,null,2,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,null,1,1,1,1,null,1,null,1,null,1,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,2,2,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,4,null,4,null,4,3,3,1,null,null,4,4,null,null,null,null,null,null,1,null,1,1,null,1,1,1,1,null,null,null,null,null,null,null,null,null,95,null,95,95,95,95,null,null,null,null,null,null,null,null,1,null,1,1,1,1,null,null,null,null,null,null,null,null,null,3,null,3,2,2,null,2,null,null,null,null,null,null,null,null,null,null,null,2,null,2,1,null,1,null,1,null,null,null,null,null,null,null,null,null,21,null,21,21,21,null,null,null,null,null,null,null,null,null,4,null,4,3,null,3,null,null,null,null,null,null,null,null,null,null,null,2,null,2,1,null,1,null,1,null,null,null,null,null,null,null,null,null,null,13,null,13,1,1,13,11,11,11,1,1,1,1,null,13,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,5,null,5,null,3,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,8,null,8,null,7,2,2,5,5,5,5,5,null,null,7,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,12,null,12,11,null,10,null,10,8,null,8,8,8,8,8,null,10,null,null,null,null,null,null,null,null,null,null,null,null,null,4,null,null,4,4,null,4,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,null,3,3,null,3,null,null,null,null,null,null,null,null,null,null,null,null,null,5,null,5,2,null,null,5,null,5,5,4,null,4,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,4,null,4,1,4,3,3,null,4,4,3,null,4,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,null,4,3,3,null,null,null,null,null,null,null,null,null,null,null,4,null,4,3,null,null,null,null,null,null,null,null,null,98,null,98,null,null,null,null,96,9,null,9,9,9,9,9,9,null,9,9,9,null,9,null,null,96,95,95,null,95,95,95,95,96,null,null,null,null,null,null,null,null,null,null,null,null,4,null,4,3,null,null,null,null,null,null,null,null,null,null,null,16,null,16,null,15,15,15,15,null,null,null,null,null,null,null,null,null,null,null,null,null,10,null,10,8,7,7,null,null,null,null,null,null,null,null,null,null,null,null,14,null,14,null,13,null,null,13,9,null,9,2,9,3,3,null,9,null,9,9,9,null,null,9,4,4,4,4,null,13,null,null,null,null,null,null,null,null,null,null,6,null,6,5,4,4,null,null,null,null,null,null,null,null,null,null,null,5,null,5,4,null,3,3,3,3,null,null,null,null,null,null,null,null,null,null,null,4,null,4,1,1,null,4,1,1,null,4,1,null,null,3,1,null,null,2,2,2,null,2,null,null,null,null,null,null,null,null,3,null,3,null,null,null,null,null,null,null,null,5,null,5,null,null,null,null,5,null,5,null,null,null,null,5,null,5,5,null,null,null,4,null,4,4,null,null,null,3,null,3,null,3,3,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,2,null,2,1,1,1,null,null,2,2,2,2,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,2,2,null,null,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null,null,null,null,1,null,1,1,1,1,null,1,null,null,null,null,null,null,1,null,1,1,1,1,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,1,null,1,1,1,null,null,null,null,null,null,null,null,null,null,null,null,144,null,144,null,null,null,null,null,null,null,null,null,118,null,118,118,118,118,null,null,null,null,null,null,1,null,1,1,null,null,null,null,null,null,null,114,65,65,null,114,13,13,null,114,17,null,101,null,null,null,null,null,null,null,25,25,25,null,25,19,19,null,25,20,20,25,null,null,null,null,null,null,null,97,null,97,97,null,97,14,14,97,null,null,null,null,null,null,null,null,29,3,27,3,24,3,null,21,null,null,null,null,null,null,null,null,null,null,115,115,null,115,104,104,44,44,31,31,null,null,115,null,115,null,null,null,null,null,null]}]}